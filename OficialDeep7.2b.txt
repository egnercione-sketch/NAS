# ============================================
# NBA ANALYTICS SUITE v1.6 (Enhanced Modular Version with Strategic Engine)
# ============================================
import os
import pickle
import time
import json
import re
import tempfile
import unicodedata
import difflib
from datetime import datetime, timedelta
from itertools import combinations
import random
import requests
import pandas as pd
import streamlit as st
import numpy as np
# ============================================================================
# CONFIGURAÇÃO (de config.py)
# ============================================================================
BASE_DIR = os.path.dirname(__file__)
CACHE_DIR = os.path.join(BASE_DIR, "cache")
os.makedirs(CACHE_DIR, exist_ok=True)
L5_CACHE_FILE = os.path.join(CACHE_DIR, "l5_players.pkl")
SCOREBOARD_JSON_FILE = os.path.join(CACHE_DIR, "scoreboard_today.json")
TEAM_ADVANCED_FILE = os.path.join(CACHE_DIR, "team_advanced.json")
TEAM_OPPONENT_FILE = os.path.join(CACHE_DIR, "team_opponent.json")
NAME_OVERRIDES_FILE = os.path.join(CACHE_DIR, "name_overrides.json")
ODDS_CACHE_FILE = os.path.join(CACHE_DIR, "odds_today.json")
INJURIES_CACHE_FILE = os.path.join(CACHE_DIR, "injuries_cache_v44.json")
MOMENTUM_CACHE_FILE = os.path.join(CACHE_DIR, "momentum_cache.json")
TESES_CACHE_FILE = os.path.join(CACHE_DIR, "teses_cache.json")
DVP_CACHE_FILE = os.path.join(CACHE_DIR, "dvp_cache.json")
AUDIT_CACHE_FILE = os.path.join(CACHE_DIR, "audit_trixies.json")
FEATURE_STORE_FILE = os.path.join(CACHE_DIR, "feature_store.json")  # NOVO
SEASON = "2025-26"
TODAY = datetime.now().strftime("%Y-%m-%d")
TODAY_YYYYMMDD = datetime.now().strftime("%Y%m%d")
ESPN_SCOREBOARD_URL = "https://site.web.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard"
ESPN_TEAM_ROSTER_TEMPLATE = "https://site.web.api.espn.com/apis/site/v2/sports/basketball/nba/teams/{team}/roster"
ESPN_BOXSCORE_URL = "https://site.web.api.espn.com/apis/site/v2/sports/basketball/nba/summary"
ODDS_API_KEY = "8173a928aa76a59f5aa16bb71666fb8d"
ODDS_API_URL = "https://api.the-odds-api.com/v4/sports/basketball_nba/odds"
HEADERS = {"User-Agent": "Mozilla/5.0"}
TEAM_ABBR_TO_ODDS = {
    "ATL": "Atlanta Hawks","BOS": "Boston Celtics","BKN": "Brooklyn Nets","CHA": "Charlotte Hornets",
    "CHI": "Chicago Bulls","CLE": "Cleveland Cavaliers","DAL": "Dallas Mavericks","DEN": "Denver Nuggets",
    "DET": "Detroit Pistons","GSW": "Golden State Warriors","HOU": "Houston Rockets","IND": "Indiana Pacers",
    "LAC": "Los Angeles Clippers","LAL": "Los Angeles Lakers","MEM": "Memphis Grizzlies","MIA": "Miami Heat",
    "MIL": "Milwaukee Bucks","MIN": "Minnesota Timberwolves","NOP": "New Orleans Pelicans","NYK": "New York Knicks",
    "OKC": "Oklahoma City Thunder","ORL": "Orlando Magic","PHI": "Philadelphia 76ers","PHX": "Phoenix Suns",
    "POR": "Portland Trail Blazers","SAC": "Sacramento Kings","SAS": "San Antonio Spurs","TOR": "Toronto Raptors",
    "UTA": "Utah Jazz","WAS": "Washington Wizards",
    # Variações ESPN
    "UTAH": "Utah Jazz","NY": "New York Knicks","SA": "San Antonio Spurs","NO": "New Orleans Pelicans"
}
ESPN_TEAM_CODES = {
    "ATL": "atl", "BOS": "bos", "BKN": "bkn", "CHA": "cha", "CHI": "chi",
    "CLE": "cle", "DAL": "dal", "DEN": "den", "DET": "det", "GSW": "gsw",
    "HOU": "hou", "IND": "ind", "LAC": "lac", "LAL": "lal", "MEM": "mem",
    "MIA": "mia", "MIL": "mil", "MIN": "min",
    "NOP": "nor", "NO": "nor",  # Corrigido: New Orleans Pelicans usa "nor"
    "NYK": "ny", "OKC": "okc", "ORL": "orl", "PHI": "phi", "PHX": "pho",  # Corrigido: Phoenix Suns usa "pho"
    "POR": "por", "SAC": "sac", "SAS": "sa", "TOR": "tor", "UTA": "uta",
    "WAS": "wsh",
    "UTAH": "uta", "NY": "ny", "SA": "sa"
}
# ============================================================================
# NOVO: TEAM PACE DATA (FASE 1A) - ATUALIZADO
# ============================================================================
TEAM_PACE_DATA = {
    "ATL": 101.2, "BOS": 100.5, "BKN": 98.5, "CHA": 100.5,
    "CHI": 99.2, "CLE": 98.0, "DAL": 100.8, "DEN": 102.1,
    "DET": 100.3, "GSW": 102.5, "HOU": 101.7, "IND": 104.5,
    "LAC": 100.9, "LAL": 101.3, "MEM": 99.5, "MIA": 98.8,
    "MIL": 101.0, "MIN": 99.0, "NOP": 101.4, "NYK": 99.1,
    "OKC": 102.3, "ORL": 99.4, "PHI": 100.7, "PHX": 101.6,
    "POR": 102.0, "SAC": 104.0, "SAS": 100.1, "TOR": 101.9,
    "UTA": 101.5, "WAS": 102.2
}
# ============================================================================
# NOVAS VARIÁVEIS GLOBAIS (FASE 1.1)
# ============================================================================
TEAM_STATS_AVG = {
    "PTS": 115.0, "REB": 45.5, "AST": 26.0, "PRA": 186.5,
    "STL": 7.2, "BLK": 5.1, "3PM": 12.3
}
TRIXIE_WEIGHT_MAP = {
    "main": {"basePRA": 0.9, "MinutesSafe": 1.0, "LowVariance": 0.8, "UsageSpike": 0.4, 
             "corrPenalty": 1.0, "underdog": 0.2, "high_pace": 0.1},
    "upside": {"basePRA": 0.6, "UsageSpike": 1.6, "ThreePointPotential": 1.8, "BenchMonster": 0.8, 
               "GarbageTimeHistorico": 1.3, "LowAvgPenalty": -0.5, "corrPenalty": 0.6, "underdog": 0.4, "high_pace": 0.2},
    "highvalue": {"basePRA": 0.9, "BigRebound": 1.4, "HiddenAssistValue": 1.3, 
                  "DVPPointsMatchup": 1.2, "corrPenalty": 1.1, "underdog": 0.1, "high_pace": 0.15},
    "boost": {"basePRA": 1.5, "CeilingPRA": 1.8, "UsageSpike": 1.4, 
              "StealPotential": 1.3, "BlockPotential": 1.3, "ThreePointPotential": 1.2,
              "underdog": 0.25, "high_pace": 0.3, "blowout_risk": 0.15}
}
# Atualizar TESE_LIST existente
TESE_LIST = [
    "MinutesSafe", "BigRebound", "UsageSpike", "SynergyRebAst", "LowVariance",
    "TripleThreat", "HiddenReboundValue", "HiddenAssistValue",
    "ReboundMatchup", "AssistMatchup", "HybridRole",
    "RookieBlindado", "BenchMonster", "B2BAzarao",
    "GarbageTimeHistorico", "ViagemLonga", "PivoSobrevivente",
    "DVPPointsMatchup", "DVPReboundMatchup", "DVPAssistMatchup",
    "StealPotential", "BlockPotential", "ThreePointPotential", "CeilingExplosion"  # NOVAS
]
UPSIDE_TESES = [
    "ThreePointPotential",      # ← novo no topo
    "DVPPointsMatchup",         # ← novo no topo
    "UsageSpike",
    "GarbageTimeHistorico",
    "BenchMonster",             # só passa se já tiver passado o filtro acima
    "RookieBlindado",
    "HiddenReboundValue",
    "HiddenAssistValue",
    "PivoSobrevivente",
    "DVPReboundMatchup",
    "DVPAssistMatchup"
]
HIGHVALUE_TESES = [
    "MinutesSafe", "LowVariance", "TripleThreat",
    "SynergyRebAst", "ReboundMatchup", "AssistMatchup",
    "DVPPointsMatchup", "DVPReboundMatchup", "DVPAssistMatchup"
]
# NOVO: BOOST TESES
BOOST_TESES = [
    "CeilingExplosion", "UsageSpike", "StealPotential", 
    "BlockPotential", "ThreePointPotential", "PivoSobrevivente",
    "BenchMonster", "GarbageTimeHistorico", "DVPPointsMatchup",
    "DVPReboundMatchup", "DVPAssistMatchup"
]
# ============================================================================
# NEW MODULE IMPORTS (FASE 1)
# ============================================================================
try:
    # Módulos do sistema estratégico
    from modules.new_modules.thesis_engine import ThesisEngine
    from modules.new_modules.strategy_engine import StrategyEngine
    from modules.new_modules.narrative_formatter import NarrativeFormatter
    from modules.new_modules.rotation_analyzer import RotationAnalyzer
    from modules.new_modules.multipla_do_dia import MultiplaDoDia
    # Módulos existentes (mantidos do sistema original)
    from modules.new_modules.player_classifier import PlayerClassifier
    from modules.new_modules.strategy_identifier import StrategyIdentifier
    from modules.new_modules.correlation_filters import CorrelationValidator
    from modules.new_modules.archetype_engine import ArchetypeEngine
    from modules.new_modules.rotation_ceiling_engine import RotationCeilingEngine
    NOVOS_MODULOS_DISPONIVEIS = True
    print("✅ Módulos estratégicos carregados com sucesso")
except ImportError as e:
    print(f"⚠️ Atenção: Módulos estratégicos não encontrados: {e}")
    print("⚠️ O sistema funcionará em modo de compatibilidade")
    NOVOS_MODULOS_DISPONIVEIS = False
except Exception as e:
    print(f"⚠️ Erro ao carregar módulos estratégicos: {e}")
    NOVOS_MODULOS_DISPONIVEIS = False
try:
    from modules.new_modules.pace_adjuster import PaceAdjuster
    PACE_ADJUSTER_AVAILABLE = True
except ImportError:
    PACE_ADJUSTER_AVAILABLE = False
    PaceAdjuster = None
try:
    from modules.new_modules.vacuum_matrix import VacuumMatrixAnalyzer
    VACUUM_MATRIX_AVAILABLE = True
except ImportError:
    VACUUM_MATRIX_AVAILABLE = False
    VacuumMatrixAnalyzer = None
try:
    from modules.new_modules.correlation_filters import TrixieCorrelationValidator
    CORRELATION_FILTERS_AVAILABLE = True
except ImportError:
    CORRELATION_FILTERS_AVAILABLE = False
    TrixieCorrelationValidator = None
try:
    from modules.new_modules.enhanced_system import EnhancedTrixieSystem
    ENHANCED_SYSTEM_AVAILABLE = True
except ImportError:
    ENHANCED_SYSTEM_AVAILABLE = False
    EnhancedTrixieSystem = None
from modules.new_modules.archetype_engine import ArchetypeEngine
try:
    from modules.new_modules.dvp_analyzer import DvPAnalyzer, DefenseDataFetcher, tese_dvp_points_matchup, tese_dvp_rebound_matchup, tese_dvp_assist_matchup
    DVP_MODULE_AVAILABLE = True
except ImportError:
    DVP_MODULE_AVAILABLE = False
    DvPAnalyzer = None
import logging
logger = logging.getLogger(__name__)
# ============================================================================
# Feature Flags (nova seção atualizada) - FASE 1.1
# ============================================================================
FEATURE_FLAGS = {
    "ADVANCED_PROJECTIONS": True,
    "INJURY_RIPPLE_EFFECT": True,
    "USAGE_SPIKE_DETECTOR": True,
    "MATCHUP_CLASSIFIER": True,
    "SAVE_FAVORITES": True,
    "AUDIT_SYSTEM": True,
    "PACE_ADJUSTER": True,
    "VACUUM_MATRIX": True,
    "CORRELATION_FILTERS": True,
    "ENHANCED_SYSTEM": True,
    "DYNAMIC_THRESHOLDS": True,
    "CONTEXTUAL_SCORING": True,
    "BOOST_MODE": True,
    "STRATEGIC_ENGINE": True  # NOVO
}
# Configurações de performance - FASE 1.2
PERFORMANCE_CONFIG = {
    "max_api_calls_per_minute": 60,
    "cache_ttl_minutes": {
        "injuries": 5,
        "odds": 2,
        "stats": 30,
        "projections": 60
    },
    "max_trixies_per_game": {
        "main": 20,
        "upside": 15,
        "highvalue": 12,
        "boost": 15
    },
    "strategic": {
        "max_per_category": 6,  # Máximo de recomendações por categoria
        "min_confidence": 0.6   # Confiança mínima para recomendar
    }
}
# ============================================================================
# UTILITÁRIOS BÁSICOS (de utils.py)
# ============================================================================
# [CÓDIGO DE UTILITÁRIOS MANTIDO IGUAL AO ORIGINAL]
def normalize_name(n: str) -> str:
    if not n: return ""
    n = str(n).lower()
    n = n.replace(".", " ").replace(",", " ").replace("-", " ")
    n = re.sub(r"\b(jr|sr|ii|iii|iv)\b", "", n)
    n = unicodedata.normalize("NFKD", n).encode("ascii","ignore").decode("ascii")
    return " ".join(n.split())
def safe_abs_spread(val):
    if val is None: return 0.0
    try: return abs(float(val))
    except Exception: return 0.0
def _status_is_out_or_questionable(status: str) -> bool:
    s = (status or "").lower()
    return ("out" in s) or ("questionable" in s) or ("injur" in s) or ("ir" in s)
def atomic_save(path, obj_bytes):
    dirpath = os.path.dirname(path) or "."
    fd, tmp = tempfile.mkstemp(dir=dirpath)
    try:
        with os.fdopen(fd, "wb") as f: f.write(obj_bytes)
        os.replace(tmp, path); return True
    except Exception:
        try:
            if os.path.exists(tmp): os.remove(tmp)
        except Exception: pass
        return False
def save_pickle(path, obj):
    try:
        data = pickle.dumps(obj)
        return atomic_save(path, data)
    except Exception:
        return False
def load_pickle(path):
    try:
        if not os.path.exists(path): return None
        with open(path, "rb") as f: return pickle.load(f)
    except Exception:
        return None
def save_json(path, obj):
    try:
        data = json.dumps(obj, ensure_ascii=False, indent=2).encode("utf-8")
        return atomic_save(path, data)
    except Exception:
        return False
def load_json(path):
    try:
        if not os.path.exists(path): return None
        with open(path, "r", encoding="utf-8") as f: return json.load(f)
    except Exception:
        return None
class SafetyUtils:
    @staticmethod
    def safe_get(data, keys, default=None):
        try:
            if isinstance(keys, str):
                keys = [keys]
            current = data
            for key in keys:
                if isinstance(current, dict) and key in current:
                    current = current[key]
                elif isinstance(current, list) and isinstance(key, int) and 0 <= key < len(current):
                    current = current[key]
                else:
                    return default
            return current if current is not None else default
        except:
            return default
    @staticmethod
    def safe_float(value, default=0.0):
        try:
            if value is None:
                return default
            if isinstance(value, (int, float)):
                return float(value)
            if isinstance(value, str):
                cleaned = ''.join(c for c in value if c.isdigit() or c in '.-')
                return float(cleaned) if cleaned else default
            return float(value)
        except:
            return default
def safe_get(dictionary, key, default=None):
    """Acesso seguro a dicionários com fallback"""
    return dictionary.get(key, default)
def calculate_percentiles(values, percentiles=[90, 95]):
    """Calcula percentis de uma lista de valores"""
    if not values:
        return {}
    results = {}
    for p in percentiles:
        results[f'p{p}'] = np.percentile(values, p)
    return results
def exponential_backoff(attempt, max_delay=60):
    """Calcula delay para retry com backoff exponencial"""
    return min(max_delay, (2 ** attempt))
# Injuries (flexível)
try:
    from injuries import InjuryMonitor
except Exception:
    InjuryMonitor = None
def init_injury_monitor_flexible():
    if InjuryMonitor is None: return None
    tries = [
        {"cache_file": INJURIES_CACHE_FILE, "ttl_hours": 24},
        {"cache_path": INJURIES_CACHE_FILE, "ttl_hours": 24},
        {"cache_file": INJURIES_CACHE_FILE},
        {"cache_path": INJURIES_CACHE_FILE},
        {}
    ]
    for kwargs in tries:
        try:
            im = InjuryMonitor(**kwargs) if kwargs else InjuryMonitor()
            return im
        except TypeError:
            continue
        except Exception:
            return None
    try:
        return InjuryMonitor()
    except Exception:
        return None
def load_name_overrides():
    data = load_json(NAME_OVERRIDES_FILE)
    return data or {}
def save_name_overrides(overrides):
    save_json(NAME_OVERRIDES_FILE, overrides)

# ============================================================================
# NOVO: FUNÇÕES DE THRESHOLDS DINÂMICOS (FASE 2.1)
# ============================================================================

def calculate_dynamic_threshold(stat, player_data=None, team_data=None):
    league_avg = TEAM_STATS_AVG.get(stat, 0)
    threshold = league_avg
    pos_multiplier = 1.0
    if player_data:
        position = player_data.get("position", "").upper()
        pos_map = {
            "PG": {"PTS": 1.3, "AST": 1.5, "REB": 0.8},
            "SG": {"PTS": 1.3, "AST": 1.1, "REB": 0.8},
            "SF": {"PTS": 1.1, "AST": 0.9, "REB": 1.2},
            "PF": {"PTS": 1.0, "AST": 0.8, "REB": 1.5},
            "C":  {"PTS": 1.0, "AST": 0.6, "REB": 2.0}
        }
        if position in pos_map and stat in pos_map[position]:
            pos_multiplier = pos_map[position][stat]
    adjusted = threshold * pos_multiplier
    # Remover multiplicação duplicada
    adjusted = max(adjusted * 0.7, min(adjusted * 1.3, adjusted))
    return round(adjusted, 1)  # ← Arredondar para 1 casa decimal


def get_team_average_stats(team_abbr, df_l5):
    """Calcula estatísticas médias do time"""
    if df_l5.empty:
        return TEAM_STATS_AVG.copy()
    
    team_players = df_l5[df_l5["TEAM"] == team_abbr]
    if team_players.empty:
        return TEAM_STATS_AVG.copy()
    
    return {
        "PTS": team_players["PTS_AVG"].mean(),
        "REB": team_players["REB_AVG"].mean(),
        "AST": team_players["AST_AVG"].mean(),
        "PRA": team_players["PRA_AVG"].mean()
    }

# ============================================================================
# NOVO: FEATURE STORE LEVE (FASE 2.2)
# ============================================================================

class FeatureStore:
    """Cache centralizado de features"""
    def __init__(self, cache_file=FEATURE_STORE_FILE):
        self.cache_file = cache_file
        self.data = self._load_data()
    
    def _load_data(self):
        try:
            if os.path.exists(self.cache_file):
                with open(self.cache_file, 'r', encoding='utf-8') as f:
                    cache_data = json.load(f)
                    cache_time = datetime.fromisoformat(cache_data.get("timestamp", "1970-01-01"))
                    if (datetime.now() - cache_time).total_seconds() < 900:  # 15 minutos
                        return cache_data.get("data", {})
        except Exception:
            pass
        return {}
    
    def _save_data(self):
        try:
            cache_data = {
                "timestamp": datetime.now().isoformat(),
                "data": self.data
            }
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, indent=2, ensure_ascii=False)
        except Exception:
            pass
    
    def get_game_features(self, game_id, away_abbr, home_abbr, df_l5, odds_map, team_advanced, team_opponent):
        """Obtém features para um jogo específico"""
        cache_key = f"{game_id}_{away_abbr}_{home_abbr}"
        
        if cache_key in self.data:
            return self.data[cache_key]
        
        # Construir features (simplificado)
        game_ctx = build_game_context(away_abbr, home_abbr, odds_map, team_advanced, team_opponent)
        
        # Adicionar features avançadas
        home_pace = TEAM_PACE_DATA.get(home_abbr, 100.0)
        away_pace = TEAM_PACE_DATA.get(away_abbr, 100.0)
        game_pace = (home_pace + away_pace) / 2.0
        
        result = {
            "game_ctx": {
                **game_ctx,
                "game_pace": game_pace,
                "is_high_pace": game_pace > 102,
                "is_low_pace": game_pace < 98
            },
            "calculated_at": datetime.now().isoformat()
        }
        
        self.data[cache_key] = result
        self._save_data()
        
        return result

# ============================================================================
# NOVO: FUNÇÕES DE COMPATIBILIDADE (FASE 1)
# ============================================================================

def apply_pace_adjustment_simple(player_stats, home_team, away_team):
    """
    Ajuste de pace SIMPLES (fallback se módulo não estiver disponível)
    """
    if not player_stats or not home_team or not away_team:
        return player_stats
    
    home_pace = TEAM_PACE_DATA.get(home_team, 100.0)
    away_pace = TEAM_PACE_DATA.get(away_team, 100.0)
    game_pace = (home_pace + away_pace) / 2.0
    
    # Fator de ajuste
    pace_factor = game_pace / 100.0
    
    # Apenas stats de volume
    volume_stats = ['pts_L5', 'reb_L5', 'ast_L5', 'pra_L5']
    
    adjusted = player_stats.copy()
    
    for stat in volume_stats:
        if stat in adjusted and adjusted[stat] > 0:
            adjusted[stat] = round(adjusted[stat] * pace_factor, 1)
    
    # Metadata
    adjusted['pace_adjusted'] = True
    adjusted['game_pace'] = round(game_pace, 1)
    adjusted['pace_factor'] = round(pace_factor, 3)
    
    return adjusted

def build_player_ctx_with_enhancements(roster_entry, df_l5_row, team_context, 
                                      opponent_context, game_context, dvp_analyzer=None):
    """
    Versão aprimorada do build_player_ctx com todos os enhancements
    """
    # Contexto básico (original)
    basic_ctx = build_player_ctx(roster_entry, df_l5_row, team_context, opponent_context, dvp_analyzer)
    
    # Verificar se features avançadas estão ativas
    if not st.session_state.get("use_advanced_features", False):
        return basic_ctx
    
    config = st.session_state.get("advanced_features_config", {})

    # ================================
    # Integração com Archetype Engine
    # ================================
    if "archetype_engine" in st.session_state:
        player_id = roster_entry.get("id")

        # Montar métricas relevantes para classificação
        player_stats = {
            "PTS_AVG": df_l5_row.get("PTS_AVG", 0),
            "REB_AVG": df_l5_row.get("REB_AVG", 0),
            "AST_AVG": df_l5_row.get("AST_AVG", 0),
            "FTA_AVG": df_l5_row.get("FTA_AVG", 0),          # FoulMerchant
            "THREEPA_AVG": df_l5_row.get("THREEPA_AVG", 0),  # VolumeShooter
            "OREB_PCT": df_l5_row.get("OREB_PCT", 0),        # GlassBanger
            "STL_AVG": df_l5_row.get("STL_AVG", 0),          # PerimeterLock
            "BLK_AVG": df_l5_row.get("BLK_AVG", 0),          # PaintBeast complemento
            "USAGE_RATE": df_l5_row.get("USAGE_RATE", 0),    # Distributor
            "AST_TO_RATIO": df_l5_row.get("AST_TO_RATIO", 0),
            "CLUTCH_PTS": df_l5_row.get("CLUTCH_PTS", 0),    # ClutchPerformer
            "CLUTCH_FG": df_l5_row.get("CLUTCH_FG", 0),
            "FAST_BREAK_PTS": df_l5_row.get("FAST_BREAK_PTS", 0), # TransitionDemon
            "PACE": game_context.get("game_pace", 100)       # contexto de pace
        }

        # Gerar lista de archetypes
        archetypes = st.session_state.archetype_engine.get_archetypes(player_id, player_stats)
        basic_ctx["archetypes"] = archetypes
   
    # 1. PACE ADJUSTER
    if config.get("pace_adjuster", False):
        try:
            if st.session_state.get("pace_adjuster"):
                # Usar módulo se disponível
                basic_ctx = st.session_state.pace_adjuster.adjust_player_stats(
                    basic_ctx,
                    game_context.get("home_abbr"),
                    game_context.get("away_abbr")
                )
            else:
                # Fallback simples
                basic_ctx = apply_pace_adjustment_simple(
                    basic_ctx,
                    game_context.get("home_abbr"),
                    game_context.get("away_abbr")
                )
        except Exception as e:
            st.error(f"Erro no Pace Adjuster: {e}")
    
    return basic_ctx

def build_trixies_with_enhancements(team_players_ctx, game_ctx, trixie_type="main"):
    """
    Gera trixies com enhancements ativos, incluindo Archetype Engine e mapeamento de teses
    """
    # Verificar se vamos usar enhancements
    use_enhanced = st.session_state.get("use_advanced_features", False)
    config = st.session_state.get("advanced_features_config", {})
    
    # Seleção inicial de trixies
    if trixie_type == "boost" and config.get("boost_mode", True):
        trixies = build_trixies_for_game_boost(team_players_ctx, game_ctx)
    elif not use_enhanced:
        if trixie_type == "main":
            trixies = build_trixies_for_game_main(team_players_ctx, game_ctx)
        elif trixie_type == "upside":
            trixies = build_trixies_for_game_upside(team_players_ctx, game_ctx)
        elif trixie_type == "highvalue":
            trixies = build_trixies_for_game_highvalue(team_players_ctx, game_ctx)
        else:
            trixies = build_trixies_for_game_main(team_players_ctx, game_ctx)
    else:
        enhanced_system = st.session_state.get("enhanced_system")
        if enhanced_system and ENHANCED_SYSTEM_AVAILABLE:
            try:
                trixies = enhanced_system.generate_enhanced_trixies(team_players_ctx, game_ctx)
            except Exception as e:
                st.error(f"Erro no Enhanced System: {e}")
                if trixie_type == "main":
                    trixies = build_trixies_for_game_main(team_players_ctx, game_ctx)
                elif trixie_type == "upside":
                    trixies = build_trixies_for_game_upside(team_players_ctx, game_ctx)
                elif trixie_type == "highvalue":
                    trixies = build_trixies_for_game_highvalue(team_players_ctx, game_ctx)
                else:
                    trixies = build_trixies_for_game_main(team_players_ctx, game_ctx)
        else:
            if trixie_type == "main":
                trixies = build_trixies_for_game_main(team_players_ctx, game_ctx)
            elif trixie_type == "upside":
                trixies = build_trixies_for_game_upside(team_players_ctx, game_ctx)
            elif trixie_type == "highvalue":
                trixies = build_trixies_for_game_highvalue(team_players_ctx, game_ctx)
            else:
                trixies = build_trixies_for_game_main(team_players_ctx, game_ctx)
    
    # ================================
    # Ajuste com Archetypes + Teses
    # ================================
    archetype_tese_map = {
        "PaintBeast": ["BigRebound", "ReboundMatchup", "PivoSobrevivente", "HiddenReboundValue"],
        "FoulMerchant": ["UsageSpike", "CeilingExplosion"],
        "VolumeShooter": ["ThreePointPotential", "CeilingExplosion", "GarbageTimeHistorico"],
        "Distributor": ["HiddenAssistValue", "AssistMatchup", "SynergyRebAst", "TripleThreat"],
        "GlassBanger": ["BigRebound", "ReboundMatchup", "SynergyRebAst"],
        "PerimeterLock": ["StealPotential", "BlockPotential", "LowVariance"],
        "ClutchPerformer": ["CeilingExplosion", "UsageSpike"],
        "TransitionDemon": ["ThreePointPotential", "UsageSpike", "GarbageTimeHistorico"]
    }

    if "archetype_engine" in st.session_state:
        for trixie in trixies:
            trixie.setdefault("teses_reforcadas", [])
            for player in trixie.get("players", []):
                archetypes = player.get("archetypes", [])
                if not archetypes:
                    continue

                for arche in archetypes:
                    if arche in archetype_tese_map:
                        # Reforço no score
                        if arche == "PaintBeast":
                            trixie["score"] *= 1.10
                        elif arche == "VolumeShooter":
                            trixie["score"] *= 1.08
                        elif arche == "Distributor":
                            trixie["score"] *= 1.05
                        elif arche == "PerimeterLock":
                            trixie["score"] *= 1.04
                        elif arche == "ClutchPerformer" and game_ctx.get("is_close_game", False):
                            trixie["score"] *= 1.12
                        elif arche == "TransitionDemon" and game_ctx.get("is_high_pace", False):
                            trixie["score"] *= 1.07
                        elif arche == "FoulMerchant":
                            trixie["score"] *= 1.06
                        elif arche == "GlassBanger":
                            trixie["score"] *= 1.09

                        # Registrar teses reforçadas
                        trixie["teses_reforcadas"].extend(archetype_tese_map[arche])

    # Aplicar correlation filters
    if use_enhanced and config.get("correlation_filters", False) and st.session_state.get("correlation_validator"):
        try:
            filtered_trixies = []
            for trixie in trixies:
                is_valid, violations, score_adj = st.session_state.correlation_validator.validate_trixie(
                    trixie["players"]
                )
                if is_valid:
                    trixie["score"] *= score_adj
                    trixie["enhanced"] = True
                    trixie["violations"] = []
                    filtered_trixies.append(trixie)
                else:
                    trixie["filtered_out"] = True
                    trixie["violations"] = violations
            trixies = filtered_trixies
        except Exception as e:
            st.error(f"Erro nos Correlation Filters: {e}")
    
    # Filtro de diversidade
    if trixies:
        trixies = filter_diverse_trixies(trixies, min_unique_players=8, max_similarity=0.4)
    
    # Limite máximo por jogo
    max_trixies = PERFORMANCE_CONFIG["max_trixies_per_game"].get(trixie_type, 10)
    return trixies[:max_trixies]

# ============================================================================
# HEALTH CHECK LAYER
# ============================================================================

def validate_pipeline_integrity(required_components=None):
    """
    Valida se os dados necessários para o pipeline estão disponíveis.
    """
    if required_components is None:
        required_components = ['l5', 'scoreboard']
    
    checks = {
        'l5': {
            'name': 'Dados L5 (últimos 5 jogos)',
            'critical': True,
            'status': False,
            'message': ''
        },
        'scoreboard': {
            'name': 'Scoreboard do dia',
            'critical': True,
            'status': False,
            'message': ''
        },
        'odds': {
            'name': 'Odds das casas',
            'critical': False,
            'status': False,
            'message': ''
        },
        'dvp': {
            'name': 'Dados Defense vs Position',
            'critical': False,
            'status': False,
            'message': ''
        },
        'injuries': {
            'name': 'Dados de lesões',
            'critical': False,
            'status': False,
            'message': ''
        },
        'advanced_system': {
            'name': 'Sistema Avançado',
            'critical': False,
            'status': False,
            'message': ''
        }
    }
    
    # Validar L5
    if 'l5' in required_components:
        df_l5 = st.session_state.get('df_l5')
        if df_l5 is not None and hasattr(df_l5, 'shape') and not df_l5.empty:
            checks['l5']['status'] = True
            checks['l5']['message'] = f'Carregados {len(df_l5)} jogadores'
        else:
            checks['l5']['message'] = 'Dados L5 não disponíveis'
    
    # Validar scoreboard
    if 'scoreboard' in required_components:
        scoreboard = st.session_state.get('scoreboard')
        if scoreboard and len(scoreboard) > 0:
            checks['scoreboard']['status'] = True
            checks['scoreboard']['message'] = f'{len(scoreboard)} jogos hoje'
        else:
            checks['scoreboard']['message'] = 'Nenhum jogo encontrado para hoje'
    
    # Validar odds
    if 'odds' in required_components:
        odds = st.session_state.get('odds')
        if odds and len(odds) > 0:
            checks['odds']['status'] = True
            checks['odds']['message'] = f'{len(odds)} jogos com odds'
        else:
            checks['odds']['message'] = 'Odds não disponíveis'
    
    # Validar DvP
    if 'dvp' in required_components:
        dvp_analyzer = st.session_state.get('dvp_analyzer')
        if dvp_analyzer and hasattr(dvp_analyzer, 'defense_data') and dvp_analyzer.defense_data:
            checks['dvp']['status'] = True
            checks['dvp']['message'] = f'Dados de {len(dvp_analyzer.defense_data)} times'
        else:
            checks['dvp']['message'] = 'Dados DvP não disponíveis'
    
    # Validar lesões
    if 'injuries' in required_components:
        injuries = st.session_state.get('injuries_data')
        if injuries and len(injuries) > 0:
            checks['injuries']['status'] = True
            checks['injuries']['message'] = f'Lesões carregadas'
        else:
            checks['injuries']['message'] = 'Dados de lesões não disponíveis'
    
    # Validar sistema avançado
    if 'advanced_system' in required_components:
        if st.session_state.get("use_advanced_features", False):
            checks['advanced_system']['status'] = True
            checks['advanced_system']['message'] = 'Ativo'
        else:
            checks['advanced_system']['message'] = 'Inativo'
    
    # Determinar se todos os componentes críticos estão ok
    all_critical_ok = all(
        check['status'] for key, check in checks.items() 
        if key in required_components and check['critical']
    )
    
    return all_critical_ok, checks

# ============================================================================
# DATA FETCHERS (de data_fetchers.py)
# ============================================================================

def fetch_espn_scoreboard(date_yyyymmdd=None, progress_ui=True):
    date_yyyymmdd = date_yyyymmdd or TODAY_YYYYMMDD
    params = {"dates": date_yyyymmdd}
    bar = st.progress(0) if progress_ui else None
    try:
        if bar: bar.progress(10)
        r = requests.get(ESPN_SCOREBOARD_URL, params=params, timeout=10, headers=HEADERS)
        r.raise_for_status()
        j = r.json()
        save_json(SCOREBOARD_JSON_FILE, j)
        if bar: bar.progress(60)
        games = []
        for ev in j.get("events", []):
            comp_list = ev.get("competitions", []) or []
            if not comp_list: continue
            comp = comp_list[0]
            teams_comp = comp.get("competitors", []) or []
            if len(teams_comp)<2: continue
            home_team = next((t for t in teams_comp if t.get("homeAway")=="home"), teams_comp[0])
            away_team = next((t for t in teams_comp if t.get("homeAway")=="away"), teams_comp[-1])
            home = home_team.get("team", {}).get("abbreviation")
            away = away_team.get("team", {}).get("abbreviation")
            games.append({
                "gameId": ev.get("id"), 
                "away": away, 
                "home": home,
                "status": comp.get("status", {}).get("type", {}).get("description", ""),
                "startTimeUTC": comp.get("date"), 
                "raw": comp,
                "score_home": home_team.get("score"),
                "score_away": away_team.get("score")
            })
        if bar: bar.progress(100)
        return games
    except Exception:
        if bar: bar.progress(100)
        j = load_json(SCOREBOARD_JSON_FILE)
        if j:
            games = []
            for ev in j.get("events", []):
                comp_list = ev.get("competitions", []) or []
                if not comp_list: continue
                comp = comp_list[0]
                teams_comp = comp.get("competitors", []) or []
                if len(teams_comp)<2: continue
                home_team = next((t for t in teams_comp if t.get("homeAway")=="home"), teams_comp[0])
                away_team = next((t for t in teams_comp if t.get("homeAway")=="away"), teams_comp[-1])
                home = home_team.get("team", {}).get("abbreviation")
                away = away_team.get("team", {}).get("abbreviation")
                games.append({
                    "gameId": ev.get("id"), 
                    "away": away, 
                    "home": home,
                    "status": comp.get("status", {}).get("type", {}).get("description", ""),
                    "startTimeUTC": comp.get("date"), 
                    "raw": comp,
                    "score_home": home_team.get("score"),
                    "score_away": away_team.get("score")
                })
            return games
        return []

def fetch_team_roster(team_abbr_or_id, progress_ui=True):
    cache_path = os.path.join(CACHE_DIR, f"roster_{team_abbr_or_id}.json")
    cached = load_json(cache_path)
    if cached:
        return cached
    
    espn_code = ESPN_TEAM_CODES.get(team_abbr_or_id, team_abbr_or_id.lower())
    url = ESPN_TEAM_ROSTER_TEMPLATE.format(team=espn_code)
    
    try:
        if progress_ui:
            st.info(f"Buscando roster para {team_abbr_or_id}...")
        
        r = requests.get(url, timeout=10, headers=HEADERS)
        r.raise_for_status()
        jr = r.json()
        save_json(cache_path, jr)
        return jr
    except Exception as e:
        if progress_ui:
            st.warning(f"Falha ao buscar roster para {team_abbr_or_id}: {e}")
        return {}

def fetch_odds_for_today():
    params = {"apiKey": ODDS_API_KEY, "regions": "us", "markets": "spreads,totals", "oddsFormat": "decimal"}
    try:
        r = requests.get(ODDS_API_URL, params=params, timeout=15)
        r.raise_for_status()
        data = r.json()
        odds_map = {}
        for game in data:
            home_full = game.get("home_team"); away_full = game.get("away_team")
            if not home_full or not away_full: continue
            key_full = f"{away_full}@{home_full}"
            markets = game.get("bookmakers", [])
            if not markets: continue
            bm = markets[0]; bm_title = bm.get("title","unknown"); last_update = bm.get("last_update","")
            spread_val = None; total_val = None
            for market in bm.get("markets", []):
                if market.get("key")=="spreads":
                    outcomes = market.get("outcomes", [])
                    for o in outcomes:
                        if o.get("name")==home_full: spread_val = o.get("point")
                if market.get("key")=="totals":
                    outcomes = market.get("outcomes", [])
                    for o in outcomes:
                        if o.get("name")=="Over": total_val = o.get("point")
            odds_map[key_full] = {"home_full": home_full, "away_full": away_full,
                                  "spread": spread_val, "total": total_val,
                                  "bookmaker": bm_title, "last_update": last_update}
        save_json(ODDS_CACHE_FILE, odds_map)
        return odds_map
    except Exception as e:
        cached = load_json(ODDS_CACHE_FILE)
        return cached or {}

def fetch_team_advanced_stats():
    data = load_json(TEAM_ADVANCED_FILE)
    return data or {}

def fetch_team_opponent_stats():
    data = load_json(TEAM_OPPONENT_FILE)
    return data or {}

# ============================================================================
# MOMENTUM ENGINE (de data_fetchers.py)
# ============================================================================

def calculate_momentum_score(player_stats):
    if not player_stats:
        return 50.0
    
    try:
        if 'PTS_AVG' not in player_stats:
            return 50.0
        
        score = 50.0
        min_trend = player_stats.get('MIN_AVG', 0) / 30.0 * 10 if player_stats.get('MIN_AVG', 0) > 0 else 0
        score += min_trend
        
        min_cv = player_stats.get('MIN_CV', 1.0)
        if min_cv < 0.3:
            score += 10.0
        elif min_cv > 0.7:
            score -= 10.0
        
        pra_avg = player_stats.get('PRA_AVG', 0)
        if pra_avg > 25:
            score += 15.0
        elif pra_avg > 15:
            score += 5.0
        elif pra_avg < 5:
            score -= 10.0
        
        score = max(0.0, min(100.0, score))
        
        return round(score, 1)
    except Exception:
        return 50.0

def get_momentum_data():
    cached = load_json(MOMENTUM_CACHE_FILE)
    if cached:
        return cached
    
    saved = load_pickle(L5_CACHE_FILE)
    df_l5 = saved.get("df") if saved and isinstance(saved, dict) else pd.DataFrame()
    
    momentum_data = {}
    if not df_l5.empty:
        for _, row in df_l5.iterrows():
            player_id = row.get("PLAYER_ID")
            player_name = row.get("PLAYER")
            if player_id and player_name:
                momentum_score = calculate_momentum_score(row.to_dict())
                momentum_data[player_name] = {
                    "score": momentum_score,
                    "team": row.get("TEAM"),
                    "min_avg": row.get("MIN_AVG"),
                    "pra_avg": row.get("PRA_AVG")
                }
    
    save_json(MOMENTUM_CACHE_FILE, momentum_data)
    return momentum_data

# ============================================================================
# L5 (NBA API) (de data_fetchers.py)
# ============================================================================

def fetch_player_stats_safe(pid, name):
    try:
        from nba_api.stats.endpoints import commonplayerinfo, playergamelog
        
        info_df = commonplayerinfo.CommonPlayerInfo(player_id=pid).get_data_frames()[0]
        team = info_df["TEAM_ABBREVIATION"].iloc[0] if "TEAM_ABBREVIATION" in info_df.columns else None
        exp = int(info_df["SEASON_EXP"].iloc[0]) if "SEASON_EXP" in info_df.columns else 0
        logs = playergamelog.PlayerGameLog(player_id=pid, season=SEASON).get_data_frames()[0]
        if logs is None or logs.empty: return None
        logs = logs.head(10)
        for c in ["PTS","REB","AST","MIN"]:
            if c in logs.columns: logs[c] = pd.to_numeric(logs[c], errors="coerce")
        last5 = logs.head(5)
        def cv_of(s):
            s = s.dropna()
            if s.size==0 or s.mean()==0: return 1.0
            return float(s.std(ddof=0)/s.mean())
        pts_avg = float(last5["PTS"].mean()) if "PTS" in last5.columns else 0.0
        reb_avg = float(last5["REB"].mean()) if "REB" in last5.columns else 0.0
        ast_avg = float(last5["AST"].mean()) if "AST" in last5.columns else 0.0
        min_avg = float(last5["MIN"].mean()) if "MIN" in last5.columns else 0.0
        pra_avg = float((last5["PTS"]+last5["REB"]+last5["AST"]).mean()) if all(x in last5.columns for x in ["PTS","REB","AST"]) else 0.0
        pts_cv = cv_of(last5["PTS"]) if "PTS" in last5.columns else 1.0
        reb_cv = cv_of(last5["REB"]) if "REB" in last5.columns else 1.0
        ast_cv = cv_of(last5["AST"]) if "AST" in last5.columns else 1.0
        min_cv = cv_of(last5["MIN"]) if "MIN" in last5.columns else 1.0
        last_min = float(last5["MIN"].iloc[0]) if "MIN" in last5.columns and not last5["MIN"].isna().all() else min_avg
        return {
            "PLAYER_ID": int(pid), "PLAYER": name, "TEAM": team, "EXP": exp,
            "MIN_AVG": min_avg, "PTS_AVG": pts_avg, "REB_AVG": reb_avg,
            "AST_AVG": ast_avg, "PRA_AVG": pra_avg,
            "MIN_CV": min_cv, "PTS_CV": pts_cv, "REB_CV": reb_cv, "AST_CV": ast_cv,
            "LAST_MIN": last_min,
            "min_L5": min_avg, "pts_L5": pts_avg, "reb_L5": reb_avg,
            "ast_L5": ast_avg, "pra_L5": pra_avg,
        }
    except Exception:
        return None

def try_fetch_with_retry(pid, name, tries=3, delay=0.6):
    for attempt in range(tries):
        res = fetch_player_stats_safe(pid, name)
        if res: return res
        time.sleep(delay*(attempt+1))
    return None

def get_players_l5(progress_ui=True, batch_size=5):
    from nba_api.stats.static import players
    
    saved = load_pickle(L5_CACHE_FILE)
    df_cached = saved.get("df") if saved and isinstance(saved, dict) else pd.DataFrame()
    df_final = df_cached.copy() if isinstance(df_cached, pd.DataFrame) else pd.DataFrame()
    existing_ids = set(df_final["PLAYER_ID"].astype(int).tolist()) if not df_final.empty else set()
    act_players = players.get_active_players()
    dfp = pd.DataFrame(act_players)[["id","full_name"]].rename(columns={"id":"PLAYER_ID","full_name":"PLAYER"})
    bar = st.progress(0) if progress_ui else None
    status = st.empty() if progress_ui else None
    total = len(dfp); attempted=success=fail=0
    for _, row in dfp.iterrows():
        attempted += 1
        pid = int(row["PLAYER_ID"]); pname = row["PLAYER"]
        if pid in existing_ids:
            if progress_ui and status:
                status.text(f"[L5] {attempted}/{total} — pulando {pname} (cache)")
                if bar: bar.progress(attempted/total)
            continue
        stats = try_fetch_with_retry(pid, pname, tries=3, delay=0.5)
        if stats:
            df_final = pd.concat([df_final, pd.DataFrame([stats])], ignore_index=True)
            existing_ids.add(pid); success += 1
        else:
            fail += 1
        if progress_ui and status:
            status.text(f"[L5] {attempted}/{total} — sucesso: {success} | falhas: {fail}")
            if bar: bar.progress(attempted/total)
        if attempted % batch_size == 0:
            try:
                if not df_final.empty:
                    df_final["PLAYER_ID"] = df_final["PLAYER_ID"].astype(int)
                    df_final = df_final.drop_duplicates(subset="PLAYER_ID", keep="first").reset_index(drop=True)
                ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                save_pickle(os.path.join(CACHE_DIR, f"l5_players_backup_{ts}.pkl"), {"df": df_final, "timestamp": datetime.now()})
            except Exception: pass
            save_pickle(L5_CACHE_FILE, {"df": df_final, "timestamp": datetime.now()})
    if not df_final.empty:
        try: df_final["PLAYER_ID"] = df_final["PLAYER_ID"].astype(int)
        except Exception: pass
        df_final = df_final.drop_duplicates(subset="PLAYER_ID", keep="first").reset_index(drop=True)
    save_pickle(L5_CACHE_FILE, {"df": df_final, "timestamp": datetime.now()})
    if progress_ui and status:
        status.text(f"[L5] Finalizado. Tentados: {attempted} | Sucesso: {success} | Falhas: {fail}")
        time.sleep(0.6); status.empty(); 
        if bar: bar.empty()
    return df_final
# ============================================================================
# PROJECTION ENGINE (de projection_engine.py)
# ============================================================================

class ProjectionEngine:
    """
    Engine de projeções avançadas:
    - Combina season-long stats com recência
    - Aplica ajustes DvP
    - Considera fatores contextuais
    - Calcula ceilings (percentis)
    """
    
    def __init__(self, cache_dir=CACHE_DIR):
        self.cache_dir = cache_dir
        os.makedirs(cache_dir, exist_ok=True)
        
        self.season_cache_file = os.path.join(cache_dir, "season_stats_cache.json")
        self.projections_cache_file = os.path.join(cache_dir, "projections_cache.json")
        
        self.season_stats = self._load_season_stats()
        self.projections_cache = self._load_projections_cache()
        
        self.safety = SafetyUtils()
        
    def _load_season_stats(self):
        """Carrega stats da temporada do cache"""
        try:
            if os.path.exists(self.season_cache_file):
                with open(self.season_cache_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception:
            pass
        return {}
    
    def _load_projections_cache(self):
        """Carrega cache de projeções"""
        try:
            if os.path.exists(self.projections_cache_file):
                with open(self.projections_cache_file, 'r', encoding='utf-8') as f:
                    cache_data = json.load(f)
                    # Verificar se o cache não está muito antigo (< 6 horas)
                    cache_time = datetime.fromisoformat(cache_data.get("timestamp", "1970-01-01"))
                    if (datetime.now() - cache_time).total_seconds() < 21600:  # 6 horas
                        return cache_data.get("projections", {})
        except Exception:
            pass
        return {}
    
    def _save_projections_cache(self, projections):
        """Salva projeções no cache"""
        try:
            cache_data = {
                "timestamp": datetime.now().isoformat(),
                "projections": projections
            }
            with open(self.projections_cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, indent=2, ensure_ascii=False)
        except Exception:
            pass
    
    def _fetch_season_stats_for_player(self, player_id, player_name):
        """
        Busca stats da temporada para um jogador.
        Por enquanto, simula com base nos dados L5.
        """
        saved = load_pickle(L5_CACHE_FILE)
        df_l5 = saved.get("df") if saved and isinstance(saved, dict) else pd.DataFrame()
        
        if df_l5.empty:
            return None
        
        player_data = df_l5[df_l5["PLAYER_ID"] == player_id]
        if player_data.empty:
            player_data = df_l5[df_l5["PLAYER"] == player_name]
        
        if player_data.empty:
            return None
        
        row = player_data.iloc[0].to_dict()
        
        # Simular season stats
        season_stats = {
            "GP": 45,
            "MIN": row.get("MIN_AVG", 25) * 1.1,
            "PTS": row.get("PTS_AVG", 15) * 0.9,
            "REB": row.get("REB_AVG", 5) * 1.05,
            "AST": row.get("AST_AVG", 3) * 1.05,
            "FG3M": row.get("PTS_AVG", 15) * 0.3,
            "STL": 1.2,
            "BLK": 0.8,
            "TOV": 2.0,
            "PRA": row.get("PRA_AVG", 23) * 0.95
        }
        
        return season_stats
    
    def _calculate_base_projection(self, season_stats, recent_stats, weight_season=0.7, weight_recent=0.3):
        """
        Calcula projeção base combinando season stats com recent stats
        """
        if not season_stats and not recent_stats:
            return None
        
        if not season_stats:
            base_stats = recent_stats.copy()
            base_stats["source"] = "recent_only"
        elif not recent_stats:
            base_stats = season_stats.copy()
            base_stats["source"] = "season_only"
        else:
            base_stats = {}
            for stat in ["MIN", "PTS", "REB", "AST", "FG3M", "STL", "BLK", "PRA"]:
                season_val = self.safety.safe_float(season_stats.get(stat, 0))
                recent_val = self.safety.safe_float(recent_stats.get(stat, 0))
                
                if season_val > 0 and recent_val > 0:
                    base_stats[stat] = (season_val * weight_season) + (recent_val * weight_recent)
                elif season_val > 0:
                    base_stats[stat] = season_val
                else:
                    base_stats[stat] = recent_val
            
            base_stats["source"] = f"hybrid_{int(weight_season*100)}_{int(weight_recent*100)}"
        
        return base_stats
    
    def _apply_dvp_adjustments(self, base_projection, opponent_team, player_position, dvp_analyzer):
        """
        Aplica ajustes baseados em Defense vs Position
        """
        if not base_projection or not opponent_team or not player_position or not dvp_analyzer:
            return base_projection
        
        adjusted = base_projection.copy()
        
        dvp_multipliers = {
            "PTS": dvp_analyzer.get_dvp_multiplier(opponent_team, player_position, "points"),
            "REB": dvp_analyzer.get_dvp_multiplier(opponent_team, player_position, "rebounds"),
            "AST": dvp_analyzer.get_dvp_multiplier(opponent_team, player_position, "assists"),
            "FG3M": dvp_analyzer.get_dvp_multiplier(opponent_team, player_position, "points") * 0.95,
            "STL": dvp_analyzer.get_dvp_multiplier(opponent_team, player_position, "assists") * 1.1,
            "BLK": dvp_analyzer.get_dvp_multiplier(opponent_team, player_position, "rebounds") * 1.05
        }
        
        for stat, multiplier in dvp_multipliers.items():
            if stat in adjusted:
                adjusted[stat] *= multiplier
        
        if "PTS" in adjusted and "REB" in adjusted and "AST" in adjusted:
            adjusted["PRA"] = adjusted["PTS"] + adjusted["REB"] + adjusted["AST"]
        
        adjusted["dvp_applied"] = True
        adjusted["dvp_multipliers"] = dvp_multipliers
        
        return adjusted
    
    def _apply_contextual_factors(self, projection, team_context, player_context):
        """
        Aplica fatores contextuais como B2B, travel, injuries
        """
        if not projection:
            return projection
        
        contextual = projection.copy()
        
        b2b_factor = 1.0
        if player_context.get("is_b2b", False):
            if player_context.get("is_veteran", False):
                b2b_factor = 0.85
            elif player_context.get("is_young", False):
                b2b_factor = 0.95
            else:
                b2b_factor = 0.90
        
        travel_factor = 1.0
        timezones = player_context.get("timezones_traveled", 0)
        if timezones >= 3:
            travel_factor = 0.88
        elif timezones >= 2:
            travel_factor = 0.93
        
        injury_factor = 1.0
        team_injuries = player_context.get("team_injuries", 0)
        if team_injuries >= 2:
            if player_context.get("role") in ["star", "starter"]:
                injury_factor = 1.15
            else:
                injury_factor = 1.25
        
        combined_factor = b2b_factor * travel_factor * injury_factor
        
        if "MIN" in contextual:
            contextual["MIN"] *= combined_factor
        
        minute_ratio = combined_factor
        for stat in ["PTS", "REB", "AST", "FG3M", "STL", "BLK"]:
            if stat in contextual:
                contextual[stat] *= minute_ratio
        
        if "PTS" in contextual and "REB" in contextual and "AST" in contextual:
            contextual["PRA"] = contextual["PTS"] + contextual["REB"] + contextual["AST"]
        
        contextual["context_factors"] = {
            "b2b_factor": b2b_factor,
            "travel_factor": travel_factor,
            "injury_factor": injury_factor,
            "combined_factor": combined_factor
        }
        
        return contextual
    
    def _calculate_ceilings(self, projection, volatility=0.3):
        """
        Calcula ceilings (percentis 90, 95, absoluto)
        """
        if not projection:
            return {}
        
        ceilings = {}
        
        volatility_factor = 1.0 + (volatility * 0.5)
        
        stat_configs = {
            "PTS": {"90p": 1.3, "95p": 1.5, "abs": 1.8},
            "REB": {"90p": 1.4, "95p": 1.7, "abs": 2.0},
            "AST": {"90p": 1.4, "95p": 1.6, "abs": 1.9},
            "FG3M": {"90p": 1.5, "95p": 1.8, "abs": 2.2},
            "STL": {"90p": 1.6, "95p": 2.0, "abs": 2.5},
            "BLK": {"90p": 1.6, "95p": 2.0, "abs": 2.5},
            "PRA": {"90p": 1.3, "95p": 1.5, "abs": 1.8}
        }
        
        for stat, config in stat_configs.items():
            base_value = projection.get(stat, 0)
            if base_value > 0:
                for percentile, multiplier in config.items():
                    key = f"{stat}_{percentile}"
                    ceilings[key] = base_value * multiplier * volatility_factor
        
        if "MIN" in projection:
            min_base = projection["MIN"]
            ceilings["MIN_90p"] = min(min_base * 1.25, 48)
            ceilings["MIN_95p"] = min(min_base * 1.35, 48)
            ceilings["MIN_abs"] = min(min_base * 1.5, 48)
        
        return ceilings
    
    def get_player_projection(self, player_id, player_name, team, opponent, position, 
                            player_context=None, dvp_analyzer=None):
        """
        Retorna projeção completa para um jogador
        """
        cache_key = f"{player_id}_{team}_{opponent}"
        if cache_key in self.projections_cache:
            cached_proj = self.projections_cache[cache_key]
            cache_time = datetime.fromisoformat(cached_proj.get("cache_time", "1970-01-01"))
            if (datetime.now() - cache_time).total_seconds() < 7200:
                return cached_proj
        
        season_stats = self.season_stats.get(str(player_id))
        if not season_stats:
            season_stats = self._fetch_season_stats_for_player(player_id, player_name)
            if season_stats:
                self.season_stats[str(player_id)] = season_stats
        
        recent_stats = {}
        if player_context:
            recent_stats = {
                "MIN": player_context.get("min_L5", 0),
                "PTS": player_context.get("pts_L5", 0),
                "REB": player_context.get("reb_L5", 0),
                "AST": player_context.get("ast_L5", 0),
                "PRA": player_context.get("pra_L5", 0)
            }
        
        base_projection = self._calculate_base_projection(season_stats, recent_stats)
        if not base_projection:
            return None
        
        dvp_adjusted = self._apply_dvp_adjustments(base_projection, opponent, position, dvp_analyzer)
        
        contextual_projection = self._apply_contextual_factors(
            dvp_adjusted, 
            {"team": team, "opponent": opponent},
            player_context or {}
        )
        
        volatility = player_context.get("volatility_score", 0.3) if player_context else 0.3
        ceilings = self._calculate_ceilings(contextual_projection, volatility)
        
        final_projection = {
            "player_id": player_id,
            "player_name": player_name,
            "team": team,
            "opponent": opponent,
            "position": position,
            "base_projection": base_projection,
            "dvp_adjusted": dvp_adjusted != base_projection,
            "contextual_projection": contextual_projection,
            "ceilings": ceilings,
            "volatility": volatility,
            "cache_time": datetime.now().isoformat(),
            "projection_time": datetime.now().strftime("%Y-%m-d %H:%M:%S")
        }
        
        for stat in ["MIN", "PTS", "REB", "AST", "FG3M", "STL", "BLK", "PRA"]:
            final_projection[f"{stat}_proj"] = contextual_projection.get(stat, 0)
        
        self.projections_cache[cache_key] = final_projection
        self._save_projections_cache(self.projections_cache)
        
        return final_projection

# ============================================================================
# FUNÇÕES AUXILIARES PARA TRIXIES (ATUALIZADAS)
# ============================================================================
def filter_diverse_trixies(trixies, min_unique_players=8, max_similarity=0.5):
    """
    Filtra trixies para garantir diversidade e evitar repetições excessivas.
    Args:
        trixies: Lista de trixies
        min_unique_players: Mínimo de jogadores únicos nas trixies
        max_similarity: Similaridade máxima permitida entre trixies
    Returns:
        Lista de trixies filtradas e diversificadas
    """
    if not trixies:
        return trixies
    filtered = []
    used_players = set()
    player_counts = {}
    for trixie in trixies:
        players = trixie.get("players", [])
        player_names = [p.get("name") for p in players if p.get("name")]
        # Verificar se já usou muitos jogadores repetidos
        overlap = len(set(player_names) & used_players)
        similarity = overlap / len(player_names) if player_names else 0
        # Contar quantas vezes cada jogador aparece
        for name in player_names:
            player_counts[name] = player_counts.get(name, 0) + 1
        # Critérios de filtro
        if similarity > max_similarity:
            continue
        # Se jogador já aparece em muitas trixies, penalizar
        max_usage = max([player_counts.get(name, 0) for name in player_names] or [0])
        if max_usage > 3:  # Jogador em mais de 3 trixies
            trixie["score"] *= 0.8  # Penalidade
        filtered.append(trixie)
        used_players.update(player_names)
        # Limitar número de trixies mantendo diversidade
        if len(filtered) >= 10:  # Máximo de 10 trixies
            break
    return filtered

# ============================================================================
# NOVO: FUNÇÕES DO MOTOR ESTRATÉGICO
# ============================================================================
def initialize_strategic_engine():
    """Inicializa os componentes do motor estratégico com verificação completa"""
    if "use_strategic_engine" not in st.session_state:
        st.session_state.use_strategic_engine = True
    
    # Verificar se módulos estão disponíveis
    if not NOVOS_MODULOS_DISPONIVEIS:
        st.warning("⚠️ Módulos estratégicos não disponíveis.")
        return False
    
    try:
        # Inicializar componentes com verificação individual
        success_count = 0
        
        # 1. ThesisEngine
        if 'thesis_engine' not in st.session_state:
            st.session_state.thesis_engine = ThesisEngine()
            success_count += 1
        
        # 2. PlayerClassifier
        if 'player_classifier' not in st.session_state:
            st.session_state.player_classifier = PlayerClassifier()
            success_count += 1
        
        # 3. ArchetypeEngine
        if 'archetype_engine' not in st.session_state:
            st.session_state.archetype_engine = ArchetypeEngine()
            success_count += 1
        
        # 4. RotationCeilingEngine
        if 'rotation_ceiling_engine' not in st.session_state:
            st.session_state.rotation_ceiling_engine = RotationCeilingEngine()
            success_count += 1
        
        # 5. RotationAnalyzer
        if 'rotation_analyzer' not in st.session_state:
            st.session_state.rotation_analyzer = RotationAnalyzer()
            success_count += 1
        
        # 6. StrategyIdentifier
        if 'strategy_identifier' not in st.session_state:
            st.session_state.strategy_identifier = StrategyIdentifier()
            success_count += 1
        
        # 7. CorrelationValidator
        if 'correlation_validator' not in st.session_state:
            st.session_state.correlation_validator = CorrelationValidator()
            success_count += 1
        
        # 8. NarrativeFormatter
        if 'narrative_formatter' not in st.session_state:
            st.session_state.narrative_formatter = NarrativeFormatter()
            success_count += 1
        
        # Inicializar motores compostos
        if 'strategy_engine' not in st.session_state:
            st.session_state.strategy_engine = StrategyEngine(
                st.session_state.thesis_engine,
                st.session_state.correlation_validator,
                st.session_state.strategy_identifier
            )
        
        if 'multipla_do_dia' not in st.session_state:
            st.session_state.multipla_do_dia = MultiplaDoDia(
                st.session_state.strategy_engine,
                st.session_state.narrative_formatter
            )
        
        st.session_state.strategic_modules_loaded = success_count
        st.session_state.use_strategic_engine = True
        
        logger.info(f"✅ Motor estratégico inicializado com {success_count}/8 módulos")
        return True
        
    except Exception as e:
        logger.error(f"❌ Erro ao inicializar motor estratégico: {e}")
        st.error(f"Erro ao inicializar motor estratégico: {e}")
        st.session_state.use_strategic_engine = False
        return False


def generate_strategic_recommendations(game_ctx, team_players_ctx, game_info):
    """Gera recomendações estratégicas usando o novo motor (com fallback seguro)"""
    # Verifica se o motor estratégico está disponível e foi inicializado
    if not st.session_state.get("use_strategic_engine", False):
        logger.info("Motor estratégico desativado ou não disponível. Usando sistema padrão.")
        return None
    if "strategy_engine" not in st.session_state:
        logger.warning("StrategyEngine não inicializado. Pulando recomendações estratégicas.")
        return None
    
    try:
        # Converter team_players_ctx para DataFrame
        players_data = []
        for team, players in team_players_ctx.items():
            for player in players:
                player_data = player.copy()
                player_data['team'] = team
                players_data.append(player_data)
    except Exception as e:
        logger.error(f"Erro ao gerar recomendações estratégicas: {e}")
        st.error(f"Erro ao gerar recomendações: {e}")
        return None
        
        if not players_data:
            return None
            
        df_players = pd.DataFrame(players_data)
        
        # Gerar recomendações estratégicas
        strategy_recommendations = st.session_state.strategy_engine.compose_recommendations(
            df_players, 
            game_ctx
        )
        
        # Formatar narrativas
        formatted_narratives = st.session_state.narrative_formatter.format_recommendations(
            strategy_recommendations,
            game_ctx
        )
        
        # Registrar na auditoria
        audit_system = st.session_state.get("audit_system")
        if audit_system and formatted_narratives:
            for category, data in formatted_narratives.items():
                if data.get("recommendation_count", 0) > 0:
                    for player in data.get("players", []):
                        # Criar entrada de trixie para auditoria
                        trixie = {
                            "players": [player],
                            "score": player.get("confidence", 0) * 100,
                            "enhanced": True,
                            "strategy_category": category
                        }
                        audit_system.log_trixie(trixie, game_info, category)
        
        return formatted_narratives
    except Exception as e:
        st.error(f"Erro ao gerar recomendações estratégicas: {e}")
        return None

# ============================================================================
# NOVA: FUNÇÕES DE DISPLAY PARA O MOTOR ESTRATÉGICO
# ============================================================================
def display_strategic_category(formatted_narrative, category_name, game_ctx):
    """Exibe uma categoria estratégica com formatação aprimorada"""
    if not formatted_narrative.get("players"):
        st.info(f"Nenhuma recomendação disponível para a categoria {category_name}.")
        return
    
    # Exibir visão geral
    overview = formatted_narrative["overview"]
    st.markdown(overview["text"])
    
    # Exibir jogadores
    st.subheader(f"🏀 Jogadores Recomendados ({category_name})")
    
    for i, player in enumerate(formatted_narrative["players"], 1):
        with st.expander(f"{i}. {player['name']} ({player['position']} - {player['team']}) - Confiança: {player['confidence']:.1f}%"):
            # Informações básicas
            col1, col2 = st.columns([2, 1])
            with col1:
                st.markdown(f"**{player['name']}** ({player['position']})")
                st.caption(f"Time: {player['team']} | Confiança: {player['confidence']:.1f}%")
                st.markdown(player['narrative'])
                
                # Estatísticas principais
                stats = player.get('stats', {})
                if stats:
                    stats_text = f"**Estatísticas:** "
                    stats_text += f"{stats.get('pts_avg', 0):.1f} PTS, "
                    stats_text += f"{stats.get('reb_avg', 0):.1f} REB, "
                    stats_text += f"{stats.get('ast_avg', 0):.1f} AST"
                    st.write(stats_text)
            
            with col2:
                # Mercado principal
                primary_mercado = player.get('raw_data', {}).get('primary_thesis', 'PRA')
                primary_value = stats.get('pra_avg', 0) if primary_mercado == 'PRA' else stats.get('pts_avg', 0)
                
                st.metric(
                    label=primary_mercado,
                    value=f"{primary_value:.1f}",
                    help=f"Tese principal: {primary_mercado}"
                )
                
                # Strategy tags
                strategy_tags = player.get('raw_data', {}).get('strategy_tags', [])
                if strategy_tags:
                    st.write("**Estratégias identificadas:**")
                    for tag in strategy_tags[:3]:  # Mostrar só as 3 principais
                        st.caption(f"• {tag}")
    
    # Tabela compacta
    with st.expander("📊 Tabela Compacta"):
        table_df = st.session_state.narrative_formatter.generate_compact_table(
            category_name.lower(), 
            formatted_narrative["players"]
        )
        if not table_df.empty:
            st.dataframe(table_df)

def show_mapa_rotacoes():
    """Exibe o mapa de rotações com análise detalhada"""
    st.header("📊 Mapa de Rotações")
    
    # Verificar se dados estão disponíveis
    if 'scoreboard' not in st.session_state or not st.session_state.scoreboard:
        st.warning("⚠️ Nenhum jogo encontrado para hoje!")
        return
    
    games = st.session_state.scoreboard
    if not games:
        st.info("Nenhum jogo disponível.")
        return
    
    # Selecionar jogo
    game_options = [f"{g.get('away')} @ {g.get('home')}" for g in games]
    selected_game = st.selectbox("Selecione o jogo:", game_options)
    
    if not selected_game:
        return
    
    game_idx = game_options.index(selected_game)
    game = games[game_idx]
    away = game.get("away")
    home = game.get("home")
    
    # Carregar rosters
    roster_away = fetch_team_roster(away, progress_ui=False)
    roster_home = fetch_team_roster(home, progress_ui=False)
    
    list_away = extract_list(roster_away)
    list_home = extract_list(roster_home)
    
    rows_away = [normalize_roster_entry(a) for a in list_away]
    rows_home = [normalize_roster_entry(a) for a in list_home]
    
    # Contexto do matchup
    matchup_context = {
        "away_team": away,
        "home_team": home,
        "cache_key": f"{game.get('gameId', 'unknown')}_{away}_{home}"
    }
    
    # Análise de rotações
    rotation_analyzer = st.session_state.get("rotation_analyzer")
    if rotation_analyzer:
        # Preparar dados para a UI
        sidebar_data = rotation_analyzer.prepare_rotation_sidebar(matchup_context)
        
        # Exibir insights
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader(f"🏠 {home} - Análise de Rotação")
            st.markdown(sidebar_data.get("home_insights", "Sem dados disponíveis"))
            
            # Formações estáveis
            stable_lineups_home = [l for l in rotation_analyzer.rotation_signals.get(sidebar_data["cache_key"], {}).get("signals", {}).get("stable_lineups", [])
                                  if l["team"] == home][:3]
            if stable_lineups_home:
                st.subheader("🎯 Formações Estáveis")
                for lineup in stable_lineups_home:
                    players = ", ".join(lineup["lineup"])
                    st.write(f"**{players}**")
                    st.caption(f"{lineup['minutes_together']:.1f} minutos juntos | Rating: +{lineup['net_rating']:.1f}")
        
        with col2:
            st.subheader(f"✈️ {away} - Análise de Rotação")
            st.markdown(sidebar_data.get("away_insights", "Sem dados disponíveis"))
            
            # Formações estáveis para o time visitante
            stable_lineups_away = [l for l in rotation_analyzer.rotation_signals.get(sidebar_data["cache_key"], {}).get("signals", {}).get("stable_lineups", [])
                                  if l["team"] == away][:3]
            if stable_lineups_away:
                st.subheader("🎯 Formações Estáveis")
                for lineup in stable_lineups_away:
                    players = ", ".join(lineup["lineup"])
                    st.write(f"**{players}**")
                    st.caption(f"{lineup['minutes_together']:.1f} minutos juntos | Rating: +{lineup['net_rating']:.1f}")
        
        # Shocks de rotação
        shocks = rotation_analyzer.rotation_signals.get(sidebar_data["cache_key"], {}).get("signals", {}).get("lineup_shocks", [])
        if shocks:
            st.subheader("⚠️ Shocks de Rotação Detectados")
            for shock in shocks:
                st.warning(f"**{shock['team']}**: {shock['description']}")
                st.caption(f"Impacto: {shock['impact']}")

def show_multipla_do_dia():
    """Exibe a Múltipla do Dia com duas versões"""
    st.header("🎯 Múltipla do Dia")
    
    # Verificar se dados estão disponíveis
    if 'scoreboard' not in st.session_state or not st.session_state.scoreboard:
        st.warning("⚠️ Nenhum jogo encontrado para hoje!")
        return
    
    games = st.session_state.scoreboard
    if not games:
        st.info("Nenhum jogo disponível.")
        return
    
    # Configurar multipla do dia
    multipla_engine = st.session_state.get("multipla_do_dia")
    if not multipla_engine:
        st.warning("Motor da Múltipla do Dia não inicializado.")
        return
    
    # Selecionar confrontos
    game_options = [f"{g.get('away')} @ {g.get('home')}" for g in games]
    selected_games = st.multiselect("Selecione os confrontos:", game_options, default=game_options[:3])
    
    if not selected_games:
        st.info("Selecione pelo menos um confronto para gerar a Múltipla do Dia.")
        return
    
    # Contexto dos jogos selecionados
    selected_game_data = []
    for game_str in selected_games:
        away, home = game_str.split(" @ ")
        game = next((g for g in games if g.get("away") == away and g.get("home") == home), None)
        if game:
            selected_game_data.append(game)
    
    # Botão para gerar múltipla
    if st.button("🚀 Gerar Múltipla do Dia"):
        with st.spinner("Gerando recomendações estratégicas..."):
            try:
                # Gerar múltipla
                multipla_data = multipla_engine.generate_multipla(selected_game_data)
                
                if not multipla_data:
                    st.warning("Não foi possível gerar recomendações para a Múltipla do Dia.")
                    return
                
                # Exibir versões
                tab1, tab2 = st.tabs(["🟢 Versão Conservadora", "🔥 Versão Ousada"])
                
                with tab1:
                    st.subheader("🎯 Múltipla do Dia - Versão Conservadora")
                    st.info("Seleção de jogadores com alta confiança e baixa volatilidade")
                    
                    if "conservadora" in multipla_data and multipla_data["conservadora"]:
                        for i, recommendation in enumerate(multipla_data["conservadora"], 1):
                            player = recommendation["player"]
                            market = recommendation["market"]
                            confidence = recommendation["confidence"]
                            narrative = recommendation["narrative"]
                            
                            st.markdown(f"### {i}. {player['name']} ({player['position']} - {player['team']})")
                            st.metric(label=market["type"], value=f"{market['value']:.1f}", delta=f"Confiança: {confidence:.1f}%")
                            st.markdown(narrative)
                            
                            # Estatísticas
                            st.caption(f"**Estatísticas:** {player['stats']['pts_avg']:.1f} PTS, {player['stats']['reb_avg']:.1f} REB, {player['stats']['ast_avg']:.1f} AST")
                            st.caption(f"**Tese principal:** {recommendation['primary_thesis']}")
                            
                            st.markdown("---")
                    else:
                        st.info("Nenhuma recomendação conservadora disponível para hoje.")
                
                with tab2:
                    st.subheader("🎯 Múltipla do Dia - Versão Ousada")
                    st.warning("Seleção de jogadores com alto potencial e teto estatístico")
                    
                    if "ousada" in multipla_data and multipla_data["ousada"]:
                        for i, recommendation in enumerate(multipla_data["ousada"], 1):
                            player = recommendation["player"]
                            market = recommendation["market"]
                            confidence = recommendation["confidence"]
                            narrative = recommendation["narrative"]
                            
                            st.markdown(f"### {i}. {player['name']} ({player['position']} - {player['team']})")
                            st.metric(label=market["type"], value=f"{market['value']:.1f}", delta=f"Potencial: {recommendation['ceiling_score']:.1f}/10")
                            st.markdown(narrative)
                            
                            # Estatísticas e potencial
                            st.caption(f"**Estatísticas:** {player['stats']['pts_avg']:.1f} PTS, {player['stats']['reb_avg']:.1f} REB, {player['stats']['ast_avg']:.1f} AST")
                            st.caption(f"**Tese principal:** {recommendation['primary_thesis']}")
                            st.caption(f"**Projeção otimista:** {recommendation['optimistic_projection']}")
                            
                            # Riscos
                            if "risks" in recommendation:
                                st.caption(f"**Riscos:** {recommendation['risks']}")
                            
                            st.markdown("---")
                    else:
                        st.info("Nenhuma recomendação ousada disponível para hoje.")
                
                # Resumo e estratégia
                st.subheader("📊 Estratégia da Múltipla")
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    total_legs = len(multipla_data["conservadora"]) + len(multipla_data["ousada"])
                    st.metric("Total de Legs", total_legs)
                
                with col2:
                    avg_confidence = np.mean([r["confidence"] for r in multipla_data["conservadora"]]) if multipla_data["conservadora"] else 0
                    st.metric("Confiança Média (Conservadora)", f"{avg_confidence:.1f}%")
                
                with col3:
                    avg_ceiling = np.mean([r["ceiling_score"] for r in multipla_data["ousada"]]) if multipla_data["ousada"] else 0
                    st.metric("Potencial Médio (Ousada)", f"{avg_ceiling:.1f}/10")
                
                # Diversificação
                teams_conservadora = set(r["player"]["team"] for r in multipla_data["conservadora"]) if multipla_data["conservadora"] else set()
                teams_ousada = set(r["player"]["team"] for r in multipla_data["ousada"]) if multipla_data["ousada"] else set()
                
                st.subheader("🗺️ Diversificação")
                st.write(f"**Times representados (Conservadora):** {', '.join(sorted(teams_conservadora))}")
                st.write(f"**Times representados (Ousada):** {', '.join(sorted(teams_ousada))}")
                
                # Botão para exportar
                if st.button("📤 Exportar Múltipla do Dia"):
                    export_data = {
                        "date": TODAY,
                        "games": selected_games,
                        "conservadora": multipla_data["conservadora"],
                        "ousada": multipla_data["ousada"]
                    }
                    st.download_button(
                        label="📥 Baixar como JSON",
                        data=json.dumps(export_data, indent=2),
                        file_name=f"multipla_do_dia_{TODAY}.json",
                        mime="application/json"
                    )
            
            except Exception as e:
                st.error(f"Erro ao gerar Múltipla do Dia: {e}")


# ============================================================================
# DISPLAY ATUALIZADO PARA O NOVO SISTEMA ESTRATÉGICO
# ============================================================================
def display_strategic_trixies():
    """Exibe as trixies estratégicas na nova interface"""
    st.header("🎯 TRIXIE - Motor Estratégico")
    
    # Verificar se dados estão disponíveis
    if 'scoreboard' not in st.session_state or not st.session_state.scoreboard:
        st.warning("⚠️ Nenhum jogo encontrado para hoje!")
        return
    
    games = st.session_state.scoreboard
    if not games:
        st.info("Nenhum jogo disponível.")
        return
    
    # Selecionar jogo
    game_options = ["Todos os jogos"] + [f"{g.get('away')} @ {g.get('home')}" for g in games]
    selected_game = st.selectbox("Selecione o jogo:", game_options)
    
    # Gerar teses para todos os jogadores - BOTÃO ÚNICO (não em loop)
    if "thesis_engine" in st.session_state and st.button("🔍 Gerar Teses Estratégicas", key="generate_theses_global"):
        with st.spinner("Gerando teses estratégicas..."):
            try:
                # Processar cada jogo
                for idx, game in enumerate(games):
                    if selected_game != "Todos os jogos":
                        game_str = f"{game.get('away')} @ {game.get('home')}"
                        if game_str != selected_game:
                            continue
                    
                    away = game.get("away")
                    home = game.get("home")
                    
                    # Construir contexto do jogo
                    odds = st.session_state.odds or {}
                    team_adv = st.session_state.team_advanced or {}
                    team_opp = st.session_state.team_opponent or {}
                    game_ctx = build_game_context(away, home, odds, team_adv, team_opp)
                    
                    # Buscar rosters
                    roster_away = fetch_team_roster(away, progress_ui=False)
                    roster_home = fetch_team_roster(home, progress_ui=False)
                    list_away = extract_list(roster_away)
                    list_home = extract_list(roster_home)
                    rows_away = [normalize_roster_entry(a) for a in list_away]
                    rows_home = [normalize_roster_entry(a) for a in list_home]
                    
                    # DataFrame para L5
                    df_l5 = st.session_state.get("df_l5", pd.DataFrame())
                    l5_index, l5_index_norm = build_l5_indices(df_l5)
                    
                    st.subheader(f"{away} @ {home}")
                    
                    # Processar jogadores
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.markdown(f"### 🏠 {home} - Teses")
                        for player in rows_home:
                            name = player.get("PLAYER", "")
                            l5row, _ = resolve_l5_row(name, l5_index, l5_index_norm, {})
                            
                            if l5row is not None:
                                # Construir player_ctx completo
                                player_ctx = {
                                    "name": name,
                                    "id": l5row.get("PLAYER_ID", ""),
                                    "pos": player.get("POSITION", ""),
                                    "team": home,
                                    "is_starter": player.get("STARTER", False),
                                    "min_avg": l5row.get("MIN_AVG", 0),
                                    "usg": l5row.get("USG_PCT", 0) if "USG_PCT" in df_l5.columns else 20,
                                    "ppg": l5row.get("PTS_AVG", 0),
                                    "rpg": l5row.get("REB_AVG", 0),
                                    "apg": l5row.get("AST_AVG", 0),
                                    "pra": l5row.get("PRA_AVG", 0),
                                    "ast_pct": l5row.get("AST_PCT", 0) if "AST_PCT" in df_l5.columns else 0,
                                    "player_class": st.session_state.player_classifier.classify_player({
                                        "name": name,
                                        "position": player.get("POSITION", ""),
                                        "min_L5": l5row.get("MIN_AVG", 0),
                                        "reb_per_min": l5row.get("REB_AVG", 0)/max(l5row.get("MIN_AVG", 1), 1),
                                        "ast_per_min": l5row.get("AST_AVG", 0)/max(l5row.get("MIN_AVG", 1), 1),
                                        "is_starter": player.get("STARTER", False)
                                    }) if "player_classifier" in st.session_state else []
                                }
                                
                                with st.expander(f"{name} ({player.get('POSITION', '')})"):
                                    display_player_theses(player_ctx, game_ctx)
                    
                    with col2:
                        st.markdown(f"### ✈️ {away} - Teses")
                        for player in rows_away:
                            name = player.get("PLAYER", "")
                            l5row, _ = resolve_l5_row(name, l5_index, l5_index_norm, {})
                            
                            if l5row is not None:
                                player_ctx = {
                                    "name": name,
                                    "id": l5row.get("PLAYER_ID", ""),
                                    "pos": player.get("POSITION", ""),
                                    "team": away,
                                    "is_starter": player.get("STARTER", False),
                                    "min_avg": l5row.get("MIN_AVG", 0),
                                    "usg": l5row.get("USG_PCT", 0) if "USG_PCT" in df_l5.columns else 20,
                                    "ppg": l5row.get("PTS_AVG", 0),
                                    "rpg": l5row.get("REB_AVG", 0),
                                    "apg": l5row.get("AST_AVG", 0),
                                    "pra": l5row.get("PRA_AVG", 0),
                                    "ast_pct": l5row.get("AST_PCT", 0) if "AST_PCT" in df_l5.columns else 0,
                                    "player_class": st.session_state.player_classifier.classify_player({
                                        "name": name,
                                        "position": player.get("POSITION", ""),
                                        "min_L5": l5row.get("MIN_AVG", 0),
                                        "reb_per_min": l5row.get("REB_AVG", 0)/max(l5row.get("MIN_AVG", 1), 1),
                                        "ast_per_min": l5row.get("AST_AVG", 0)/max(l5row.get("MIN_AVG", 1), 1),
                                        "is_starter": player.get("STARTER", False)
                                    }) if "player_classifier" in st.session_state else []
                                }
                                
                                with st.expander(f"{name} ({player.get('POSITION', '')})"):
                                    display_player_theses(player_ctx, game_ctx)
            
            except Exception as e:
                st.error(f"Erro ao gerar teses: {e}")
                st.exception(e)
    
    # Configurar tabs para as 4 categorias
    tab1, tab2, tab3, tab4 = st.tabs(["🟢 Conservadora", "🔥 Ousada", "💰 Banco", "🚀 Explosão"])
    
    # Gerar recomendações estratégicas quando o botão é pressionado
    if st.button("🚀 Gerar Recomendações Estratégicas", key="generate_recommendations_global"):
        with st.spinner("Gerando recomendações estratégicas..."):
            try:
                # Inicializar rotation analyzer para todos os jogos
                rotation_analyzer = st.session_state.get("rotation_analyzer")
                if rotation_analyzer:
                    for game in games:
                        away = game.get("away")
                        home = game.get("home")
                        # Análise de rotações (dados devem estar em st.session_state)
                        pass
                
                # Processar cada jogo
                for idx, game in enumerate(games):
                    if selected_game != "Todos os jogos":
                        game_str = f"{game.get('away')} @ {game.get('home')}"
                        if game_str != selected_game:
                            continue
                    
                    away = game.get("away")
                    home = game.get("home")
                    st.subheader(f"{away} @ {home}")
                    
                    # Construir contexto do jogo
                    odds = st.session_state.odds or {}
                    team_adv = st.session_state.team_advanced or {}
                    team_opp = st.session_state.team_opponent or {}
                    game_ctx = build_game_context(away, home, odds, team_adv, team_opp)
                    
                    # Construir contexto dos jogadores (simplificado para o exemplo)
                    team_players_ctx = {
                        "AWAY": [],
                        "HOME": []
                    }
                    
                    # Game info para auditoria
                    game_info = {
                        "away": away,
                        "home": home,
                        "gameId": game.get("gameId"),
                        "spread": game_ctx.get("spread"),
                        "total": game_ctx.get("total")
                    }
                    
                    # Gerar recomendações estratégicas
                    recommendations = generate_strategic_recommendations(game_ctx, team_players_ctx, game_info)
                    
                    if not recommendations:
                        st.warning("Não foi possível gerar recomendações para este jogo.")
                        continue
                    
                    # Exibir em cada tab
                    with tab1:
                        if "conservadora" in recommendations:
                            display_strategic_category(recommendations["conservadora"], "Conservadora", game_ctx)
                    
                    with tab2:
                        if "ousada" in recommendations:
                            display_strategic_category(recommendations["ousada"], "Ousada", game_ctx)
                    
                    with tab3:
                        if "banco" in recommendations:
                            display_strategic_category(recommendations["banco"], "Banco", game_ctx)
                    
                    with tab4:
                        if "explosao" in recommendations:
                            display_strategic_category(recommendations["explosao"], "Explosão", game_ctx)
                    
                    # Salvar automaticamente as recomendações na auditoria
                    audit_system = st.session_state.get("audit_system")
                    if audit_system and recommendations:
                        for category, recs in recommendations.items():
                            for rec in recs[:3]:  # Salvar top 3 de cada categoria
                                trixie = {"players": [rec], "score": rec.get("confidence", 0) * 100}
                                audit_system.log_trixie(trixie, game_info, category)
                
                st.success("✅ Recomendações geradas e salvas automaticamente na auditoria!")
            
            except Exception as e:
                st.error(f"Erro ao gerar recomendações: {e}")
                st.exception(e)
    
    # Configurar tabs para as 4 categorias
    tab1, tab2, tab3, tab4 = st.tabs(["🟢 Conservadora", "🔥 Ousada", "💰 Banco", "🚀 Explosão"])
    
    # Gerar recomendações estratégicas quando o botão é pressionado
    if st.button("🚀 Gerar Recomendações Estratégicas"):
        with st.spinner("Gerando recomendações estratégicas..."):
            try:
                # Inicializar rotation analyzer para todos os jogos
                rotation_analyzer = st.session_state.get("rotation_analyzer")
                if rotation_analyzer:
                    for game in games:
                        away = game.get("away")
                        home = game.get("home")
                        # Análise de rotações (dados devem estar em st.session_state)
                        pass
                
                # Processar cada jogo
                for idx, game in enumerate(games):
                    if selected_game != "Todos os jogos":
                        game_str = f"{game.get('away')} @ {game.get('home')}"
                        if game_str != selected_game:
                            continue
                    
                    away = game.get("away")
                    home = game.get("home")
                    st.subheader(f"{away} @ {home}")
                    
                    # Construir contexto do jogo
                    odds = st.session_state.odds or {}
                    team_adv = st.session_state.team_advanced or {}
                    team_opp = st.session_state.team_opponent or {}
                    game_ctx = build_game_context(away, home, odds, team_adv, team_opp)
                    
                    # Construir contexto dos jogadores (simplificado para o exemplo)
                    team_players_ctx = {
                        "AWAY": [],
                        "HOME": []
                    }
                    
                    # Game info para auditoria
                    game_info = {
                        "away": away,
                        "home": home,
                        "gameId": game.get("gameId"),
                        "spread": game_ctx.get("spread"),
                        "total": game_ctx.get("total")
                    }
                    
                    # Gerar recomendações estratégicas
                    recommendations = generate_strategic_recommendations(game_ctx, team_players_ctx, game_info)
                    
                    if not recommendations:
                        st.warning("Não foi possível gerar recomendações para este jogo.")
                        continue
                    
                    # Exibir em cada tab
                    with tab1:
                        if "conservadora" in recommendations:
                            display_strategic_category(recommendations["conservadora"], "Conservadora", game_ctx)
                    
                    with tab2:
                        if "ousada" in recommendations:
                            display_strategic_category(recommendations["ousada"], "Ousada", game_ctx)
                    
                    with tab3:
                        if "banco" in recommendations:
                            display_strategic_category(recommendations["banco"], "Banco", game_ctx)
                    
                    with tab4:
                        if "explosao" in recommendations:
                            display_strategic_category(recommendations["explosao"], "Explosão", game_ctx)
                    
                    # Salvar automaticamente as recomendações na auditoria
                    audit_system = st.session_state.get("audit_system")
                    if audit_system and recommendations:
                        for category, recs in recommendations.items():
                            for rec in recs[:3]:  # Salvar top 3 de cada categoria
                                trixie = {"players": [rec], "score": rec.get("confidence", 0) * 100}
                                audit_system.log_trixie(trixie, game_info, category)
                
                st.success("✅ Recomendações geradas e salvas automaticamente na auditoria!")
            
            except Exception as e:
                st.error(f"Erro ao gerar recomendações: {e}")
                st.exception(e)
# ============================================================================
# ROSTER HELPERS (mantidas do original)
# ============================================================================

def _extract_str_field(val):
    if not val: return ""
    if isinstance(val, str): return val.strip()
    if isinstance(val, dict):
        for k in ("displayName","fullName","shortName","name"):
            v = val.get(k)
            if v and isinstance(v, str): return v.strip()
    return str(val)

def normalize_roster_entry(a):
    if not a or not isinstance(a, dict):
        return {"PLAYER":"", "POSITION":"", "STARTER":False, "STATUS":""}
    candidate = a.get("athlete") if a.get("athlete") else a
    player = _extract_str_field(candidate.get("displayName") or candidate.get("fullName") or candidate.get("name") or "")
    pos_raw = candidate.get("position") or candidate.get("positionType") or candidate.get("positionName") or ""
    position = _extract_str_field(pos_raw)
    status_raw = a.get("status") or a.get("injuryStatus") or candidate.get("status") or candidate.get("injuryStatus") or ""
    if isinstance(status_raw, dict):
        status = status_raw.get("name") or status_raw.get("abbreviation") or json.dumps(status_raw, ensure_ascii=False)
    else:
        status = str(status_raw)
    starter = a.get("starter")
    if starter is None:
        starter = a.get("isStarter") or candidate.get("starter") or candidate.get("isStarter") or False
    starter_flag = bool(starter) if not isinstance(starter, str) else starter.lower() in ("true","1","yes")
    return {"PLAYER": player, "POSITION": position, "STARTER": starter_flag, "STATUS": status or ""}

def derive_availability_and_expected_minutes(roster_entry, df_l5_row, treat_unknown_as_available=True):
    status = (roster_entry.get("STATUS") or "").lower()
    starter = bool(roster_entry.get("STARTER"))
    min_avg = float(df_l5_row.get("MIN_AVG", 0)) if df_l5_row is not None else 0.0
    last_min = float(df_l5_row.get("LAST_MIN", 0)) if df_l5_row is not None else 0.0
    availability = "unknown"; expected_minutes = min_avg
    if any(k in status for k in ("out","ir","injur")):
        availability = "out"; expected_minutes = 0.0
    elif starter:
        availability = "available"; expected_minutes = max(min_avg, last_min, 28.0)
    elif status and any(k in status for k in ("active","available")):
        availability = "available"; expected_minutes = max(min_avg*0.8, last_min*0.9)
    else:
        availability = "probable"; expected_minutes = max(min_avg*0.8, last_min*0.6) if treat_unknown_as_available else min_avg*0.6
    expected_minutes = float(max(0.0, expected_minutes))
    return {"availability": availability, "expected_minutes": expected_minutes}

def extract_list(jr):
    if not jr or not isinstance(jr, dict):
        return []
    
    if "athletes" in jr and isinstance(jr["athletes"], list):
        return jr["athletes"]
    
    if "roster" in jr and isinstance(jr["roster"], dict):
        if "athletes" in jr["roster"] and isinstance(jr["roster"]["athletes"], list):
            return jr["roster"]["athletes"]
    
    possible_paths = [
        ["team", "roster", "athletes"],
        ["team", "athletes"],
        ["players"],
        ["items"],
        ["results", "athletes"],
        ["data", "athletes"]
    ]
    
    for path in possible_paths:
        current = jr
        found = True
        
        for key in path:
            if isinstance(current, dict) and key in current:
                current = current[key]
            else:
                found = False
                break
        
        if found and isinstance(current, list):
            return current
    
    def find_athletes_recursive(obj, depth=0, max_depth=3):
        if depth > max_depth:
            return None
        
        if isinstance(obj, list) and len(obj) > 0:
            first_item = obj[0]
            if isinstance(first_item, dict):
                athlete_keys = ['athlete', 'player', 'displayName', 'fullName', 'firstName', 'lastName']
                if any(key in first_item for key in athlete_keys):
                    return obj
                if 'athlete' in first_item and isinstance(first_item['athlete'], dict):
                    return obj
        
        elif isinstance(obj, dict):
            for key, value in obj.items():
                if key in ['athletes', 'players', 'roster']:
                    result = find_athletes_recursive(value, depth + 1, max_depth)
                    if result:
                        return result
                result = find_athletes_recursive(value, depth + 1, max_depth)
                if result:
                    return result
        
        return None
    
    athletes = find_athletes_recursive(jr)
    if athletes:
        return athletes
    
    return []

def build_l5_indices(df_l5):
    l5_index = {}; l5_index_norm = {}
    if df_l5 is None or df_l5.empty: return l5_index, l5_index_norm
    for _, r in df_l5.iterrows():
        try: rowd = r.to_dict()
        except Exception: rowd = dict(r)
        name = rowd.get("PLAYER") or rowd.get("player") or ""
        if not name: continue
        l5_index[name] = rowd
        l5_index_norm[normalize_name(name)] = rowd
    return l5_index, l5_index_norm

def resolve_l5_row(name_espn, l5_index, l5_index_norm, overrides):
    name_norm = normalize_name(name_espn)
    if name_norm in overrides:
        target = overrides[name_norm]
        row = l5_index.get(target)
        if row is not None: return row, "override"
    row = l5_index.get(name_espn)
    if row is not None: return row, "exact"
    row = l5_index_norm.get(name_norm)
    if row is not None: return row, "normalized"
    candidates = list(l5_index.keys())
    match = difflib.get_close_matches(name_espn, candidates, n=1, cutoff=0.75)
    if match: return l5_index.get(match[0]), "fuzzy"
    candidates_norm = list(l5_index_norm.keys())
    match2 = difflib.get_close_matches(name_norm, candidates_norm, n=1, cutoff=0.75)
    if match2: return l5_index_norm.get(match2[0]), "fuzzy_norm"
    return None, "none"

# ============================================================================
# PLAYER CONTEXT (do original)
# ============================================================================

def build_player_ctx(roster_entry, df_l5_row, team_context, opponent_context, dvp_analyzer=None):
    name = roster_entry.get("PLAYER", "")
    pos = (roster_entry.get("POSITION", "") or "").upper()
    starter = bool(roster_entry.get("STARTER", False))
    status = (roster_entry.get("STATUS") or "")
    if df_l5_row is None:
        min_L5=min_L10=reb_L5=ast_L5=pts_L5=pra_L5=reb_per_min=ast_per_min=0.0
        reb_cv=ast_cv=pts_cv=min_cv=1.0; exp=99
    else:
        min_L5 = float(df_l5_row.get("MIN_AVG", 0.0)); min_L10 = min_L5
        reb_L5 = float(df_l5_row.get("REB_AVG", 0.0)); ast_L5 = float(df_l5_row.get("AST_AVG", 0.0))
        pts_L5 = float(df_l5_row.get("PTS_AVG", 0.0))
        pra_L5 = float(df_l5_row.get("PRA_AVG", pts_L5+reb_L5+ast_L5))
        reb_per_min = reb_L5/min_L5 if min_L5>0 else 0.0
        ast_per_min = ast_L5/min_L5 if min_L5>0 else 0.0
        reb_cv = float(df_l5_row.get("REB_CV", 1.0)); ast_cv = float(df_l5_row.get("AST_CV", 1.0))
        pts_cv = float(df_l5_row.get("PTS_CV", 1.0)); min_cv = float(df_l5_row.get("MIN_CV", 1.0))
        exp = int(df_l5_row.get("EXP", 99))
    derived = derive_availability_and_expected_minutes(roster_entry, df_l5_row, treat_unknown_as_available=True)
    expected_minutes = derived.get("expected_minutes", 0.0)
    is_young = exp <= 3; is_veteran = exp >= 8
    usage = "high" if pra_L5>=30 else ("medium" if pra_L5>=18 else "low")
    vol_score = (pts_cv + min_cv)/2.0
    volatility = "high" if vol_score>=0.8 else ("medium" if vol_score>=0.5 else "low")
    if starter and usage=="high": role="star"
    elif starter and usage!="low": role="starter"
    elif not starter and usage=="high": role="bench_scorer"
    elif not starter and usage=="medium": role="rotation"
    else: role="deep_bench"
    if reb_per_min>=0.22 and pts_L5<16: style="rebounder"
    elif ast_per_min>=0.18: style="playmaker"
    elif pts_L5>=18: style="scorer"
    elif reb_per_min>=0.18 and pts_L5>=12: style="hustle"
    else: style="role"
    garbage_profile = "high" if ((not starter) and is_young and volatility!="low") else ("medium" if ((not starter) and volatility=="medium") else "low")
    
    dvp_data = {}
    if dvp_analyzer and opponent_context.get("opponent_team"):
        dvp_data = dvp_analyzer.get_matchup_analysis(
            opponent_context.get("opponent_team"), 
            pos
        )
    
    return {
        "player_id": int(df_l5_row.get("PLAYER_ID")) if df_l5_row and df_l5_row.get("PLAYER_ID") is not None else None,
        "name": name, "team": team_context.get("team_abbr"), "position": pos,
        "is_starter": starter, "status": status,
        "min_L3": min_L5, "min_L5": min_L5, "min_L10": min_L10, "expected_minutes": expected_minutes,
        "pts_L5": pts_L5, "reb_L5": reb_L5, "ast_L5": ast_L5, "pra_L5": pra_L5,
        "reb_per_min": reb_per_min, "ast_per_min": ast_per_min,
        "reb_cv": reb_cv, "ast_cv": ast_cv, "pts_cv": pts_cv, "min_cv": min_cv, "exp": exp,
        "team_injuries": team_context.get("team_injuries", 0),
        "spread": float(team_context.get("spread") or 0.0),
        "is_underdog": team_context.get("is_underdog", False),
        "is_b2b": team_context.get("is_b2b", False),
        "pace_expected": team_context.get("pace_expected", None),
        "opponent_reb_rank": opponent_context.get("opponent_reb_rank", 0),
        "opponent_ast_rank": opponent_context.get("opponent_ast_rank", 0),
        "games_last_6": team_context.get("games_last_6", 0),
        "timezones_traveled": team_context.get("timezones_traveled", 0),
        "garbage_rate_L10": team_context.get("garbage_rate_L10", 0.0),
        "is_young": is_young, "is_veteran": is_veteran, "usage": usage,
        "volatility": volatility, "role": role, "style": style, "garbage_time_profile": garbage_profile,
        "dvp_data": dvp_data
    }

def build_player_ctx_enhanced(roster_entry, df_l5_row, team_context, opponent_context, 
                            dvp_analyzer=None, projection_engine=None):
    """
    Versão aprimorada que usa ProjectionEngine se disponível.
    """
    basic_ctx = build_player_ctx(roster_entry, df_l5_row, team_context, opponent_context, dvp_analyzer)
    
    if projection_engine and basic_ctx.get("player_id"):
        try:
            proj = projection_engine.get_player_projection(
                player_id=basic_ctx.get("player_id"),
                player_name=basic_ctx.get("name"),
                team=basic_ctx.get("team"),
                opponent=opponent_context.get("opponent_team"),
                position=basic_ctx.get("position"),
                player_context=basic_ctx,
                dvp_analyzer=dvp_analyzer
            )
            
            if proj:
                basic_ctx["proj_engine_used"] = True
                basic_ctx["proj_min"] = proj.get("MIN_proj", basic_ctx.get("min_L5", 0))
                basic_ctx["proj_pts"] = proj.get("PTS_proj", basic_ctx.get("pts_L5", 0))
                basic_ctx["proj_reb"] = proj.get("REB_proj", basic_ctx.get("reb_L5", 0))
                basic_ctx["proj_ast"] = proj.get("AST_proj", basic_ctx.get("ast_L5", 0))
                basic_ctx["proj_pra"] = proj.get("PRA_proj", basic_ctx.get("pra_L5", 0))
                
                ceilings = proj.get("ceilings", {})
                basic_ctx["proj_ceil_90_pts"] = ceilings.get("PTS_90p", basic_ctx.get("pts_L5", 0) * 1.3)
                basic_ctx["proj_ceil_95_pts"] = ceilings.get("PTS_95p", basic_ctx.get("pts_L5", 0) * 1.5)
                basic_ctx["proj_ceil_90_reb"] = ceilings.get("REB_90p", basic_ctx.get("reb_L5", 0) * 1.4)
                basic_ctx["proj_ceil_95_reb"] = ceilings.get("REB_95p", basic_ctx.get("reb_L5", 0) * 1.7)
                basic_ctx["proj_ceil_90_ast"] = ceilings.get("AST_90p", basic_ctx.get("ast_L5", 0) * 1.4)
                basic_ctx["proj_ceil_95_ast"] = ceilings.get("AST_95p", basic_ctx.get("ast_L5", 0) * 1.6)
                basic_ctx["proj_ceil_90_pra"] = ceilings.get("PRA_90p", basic_ctx.get("pra_L5", 0) * 1.3)
                basic_ctx["proj_ceil_95_pra"] = ceilings.get("PRA_95p", basic_ctx.get("pra_L5", 0) * 1.5)
                
                basic_ctx["proj_volatility"] = proj.get("volatility", basic_ctx.get("volatility", "medium"))
                
                basic_ctx["proj_metadata"] = {
                    "projection_time": proj.get("projection_time"),
                    "dvp_applied": proj.get("dvp_adjusted", False),
                    "context_factors": proj.get("contextual_projection", {}).get("context_factors", {})
                }
        except Exception as e:
            basic_ctx["proj_engine_error"] = str(e)
            basic_ctx["proj_engine_used"] = False
    
    return basic_ctx
# ============================================================================
# TESES ORIGINAIS ATUALIZADAS (FASE 3.1)
# ============================================================================

def tese_minutes_safe(p, game_ctx, opp_ctx): 
    return p.get("min_L5",0)>=20

def tese_big_rebound(p, game_ctx, opp_ctx, team_stats=None):
    """Versão com threshold dinâmico"""
    if team_stats is None:
        team_stats = TEAM_STATS_AVG
    
    # Threshold dinâmico baseado na média do time
    team_reb_avg = team_stats.get("REB", 44.2)
    threshold = max(6.0, team_reb_avg * 0.15)  # 15% da média do time
    
    if p.get("reb_L5", 0) < threshold:
        return False
    
    if p.get("reb_cv", 1.0) > 0.65:
        return False
    
    # Fator contextual: jogo de ritmo baixo favorece rebotes
    total = game_ctx.get("total")
    if total is not None:
        try:
            t = float(total)
            if t > 240:
                return False  # Jogo muito rápido, menos rebotes
        except Exception:
            pass
    
    return True

def tese_usage_spike(p, game_ctx, opp_ctx): 
    return (p.get("min_L5",0)>p.get("min_L10",0)) or (p.get("team_injuries",0)>0)

def tese_synergy_reb_ast(p, game_ctx, opp_ctx): 
    return p.get("reb_cv",1.0)<=0.60 and p.get("ast_cv",1.0)<=0.60

def tese_low_variance(p, game_ctx, opp_ctx): 
    return p.get("reb_cv",1.0)<=0.60 or p.get("ast_cv",1.0)<=0.60

def tese_triple_threat(p, game_ctx, opp_ctx): 
    return p.get("reb_L5",0)>=3 and p.get("ast_L5",0)>=3

def tese_hidden_rebound_value(p, game_ctx, opp_ctx): 
    return p.get("reb_per_min",0.0)>=0.20

def tese_hidden_assist_value(p, game_ctx, opp_ctx): 
    return p.get("ast_per_min",0.0)>=0.12

def tese_rebound_matchup(p, game_ctx, opp_ctx): 
    return p.get("opponent_reb_rank",0)>=20

def tese_assist_matchup(p, game_ctx, opp_ctx): 
    return p.get("opponent_ast_rank",0)>=20

def tese_hybrid_role(p, game_ctx, opp_ctx):
    pos=(p.get("position") or "").upper()
    return pos in ["SG","SF","PF"] and (p.get("reb_L5",0)>=3 or p.get("ast_L5",0)>=3)

def tese_rookie_blindado(p, game_ctx, opp_ctx):
    if p.get("exp",99)>2: return False
    cond1 = p.get("min_L3", 0) >= 32
    cond2 = p.get("min_L5",0)>=28 and p.get("team_injuries",0)>=2
    return cond1 or cond2

def tese_bench_monster(p, game_ctx, opp_ctx, team_roster_entries):
    if p.get("expected_minutes",0)<24: return False
    if p.get("pra_L5",0)<14: return False
    pos_p=(p.get("position") or "").upper()
    def same_pos_starter_out(r):
        pos=(r.get("POSITION") or "").upper()
        if pos!=pos_p: return False
        if not r.get("STARTER"): return False
        s=(r.get("STATUS") or "").lower()
        return any(k in s for k in ["out","doubt","q"])
    any_titular_out = any(same_pos_starter_out(r) for r in team_roster_entries)
    return any_titular_out

def tese_b2b_azarao(p, game_ctx, opp_ctx):
    return p.get("is_underdog",False) and p.get("is_b2b",False) and safe_abs_spread(p.get("spread"))>=8.5

def tese_garbage_time_historico(p, game_ctx, opp_ctx):
    return safe_abs_spread(p.get("spread"))>=8.5

def tese_viagem_longa(p, game_ctx, opp_ctx):
    if p.get("timezones_traveled",0)<3: return False
    if p.get("games_last_6",0)<4: return False
    return True

def tese_pivo_sobrevivente(p, game_ctx, opp_ctx, opponent_roster_entries):
    pos=(p.get("position") or "").upper()
    if pos not in ["C","PF"]: return False
    if p.get("reb_L5",0)<11.5: return False
    def big_starter_out(r):
        pos_r=(r.get("POSITION") or "").upper()
        if pos_r not in ["C","PF"]: return False
        if not r.get("STARTER"): return False
        s=(r.get("STATUS") or "").lower()
        return any(k in s for k in ["out","doubt","inj"])
    any_big_out = any(big_starter_out(r) for r in opponent_roster_entries)
    return any_big_out

# ============================================================================
# NOVAS TESES (FASE 3.1)
# ============================================================================

def tese_steal_explosion(p, game_ctx, opp_ctx):
    """Nova tese: potencial para roubos de bola"""
    stl_avg = p.get("stl_L5", 0)
    if stl_avg < 1.0:
        return False
    
    # Verificar se tem histórico de múltiplos steals
    if stl_avg >= 1.5:
        return True
    
    # Matchup favorável: adversário com muitos turnovers
    if opp_ctx.get("opponent_tov_rank", 15) >= 20:
        return True
    
    return False

def tese_block_explosion(p, game_ctx, opp_ctx):
    """Nova tese: potencial para tocos"""
    blk_avg = p.get("blk_L5", 0)
    if blk_avg < 0.8:
        return False
    
    # Pivôs têm mais potencial
    pos = p.get("position", "").upper()
    if pos in ["C", "PF"] and blk_avg >= 1.0:
        return True
    
    # Matchup: adversário tenta muitos chutes próximos
    if opp_ctx.get("opponent_paint_pts_rank", 15) >= 20:
        return True
    
    return False

def tese_three_point_potential(p, game_ctx, opp_ctx):
    """Nova tese: potencial para acertar muitos 3 pontos"""
    threes_avg = p.get("3pm_L5", 0)
    if threes_avg < 1.5:
        return False
    
    # Arremessadores de 3 têm mais potencial
    if threes_avg >= 2.5:
        return True
    
    # Matchup: adversário fraco na defesa de 3 pontos
    if opp_ctx.get("opponent_3pm_def_rank", 15) >= 20:
        return True
    
    return False

def tese_ceiling_explosion(p, game_ctx, opp_ctx):
    """Nova tese: jogador com alto teto (ceiling)"""
    # Usar ceilings do ProjectionEngine se disponível
    if "proj_ceil_95_pra" in p:
        ceiling_pra = p.get("proj_ceil_95_pra", 0)
        baseline_pra = p.get("pra_L5", 0)
        
        # Ceiling significativamente maior que baseline
        if ceiling_pra > baseline_pra * 1.3:
            return True
    
    # Fatores adicionais
    factors = []
    if p.get("usage_spike", False):
        factors.append(1)
    if p.get("team_injuries", 0) >= 2:
        factors.append(1)
    if p.get("matchup_score", 1.0) > 1.1:
        factors.append(1)
    
    return len(factors) >= 2

# ============================================================================
# GERAR TAGS ATUALIZADA (FASE 3.2)
# ============================================================================

def gerar_tags_para_jogador(p, game_ctx, team_roster_entries, opponent_roster_entries):
    """Versão atualizada com novas teses"""
    tags=[]
    if tese_minutes_safe(p,game_ctx,{}): 
        tags.append("MinutesSafe")
    if tese_big_rebound(p,game_ctx,{}): 
        tags.append("BigRebound")
    if tese_usage_spike(p,game_ctx,{}): 
        tags.append("UsageSpike")
    if tese_synergy_reb_ast(p,game_ctx,{}): 
        tags.append("SynergyRebAst")
    if tese_low_variance(p,game_ctx,{}): 
        tags.append("LowVariance")
    if tese_triple_threat(p,game_ctx,{}): 
        tags.append("TripleThreat")
    if tese_hidden_rebound_value(p,game_ctx,{}): 
        tags.append("HiddenReboundValue")
    if tese_hidden_assist_value(p,game_ctx,{}): 
        tags.append("HiddenAssistValue")
    if tese_rebound_matchup(p,game_ctx,{}): 
        tags.append("ReboundMatchup")
    if tese_assist_matchup(p,game_ctx,{}): 
        tags.append("AssistMatchup")
    if tese_hybrid_role(p,game_ctx,{}): 
        tags.append("HybridRole")
    if tese_rookie_blindado(p,game_ctx,{}): 
        tags.append("RookieBlindado")
    if tese_bench_monster(p,game_ctx,{},team_roster_entries): 
        tags.append("BenchMonster")
    if tese_b2b_azarao(p,game_ctx,{}): 
        tags.append("B2BAzarao")
    if tese_garbage_time_historico(p,game_ctx,{}): 
        tags.append("GarbageTimeHistorico")
    if tese_viagem_longa(p,game_ctx,{}): 
        tags.append("ViagemLonga")
    if tese_pivo_sobrevivente(p,game_ctx,{},opponent_roster_entries): 
        tags.append("PivoSobrevivente")
    
    if tese_dvp_points_matchup(p,game_ctx,{}): 
        tags.append("DVPPointsMatchup")
    if tese_dvp_rebound_matchup(p,game_ctx,{}): 
        tags.append("DVPReboundMatchup")
    if tese_dvp_assist_matchup(p,game_ctx,{}): 
        tags.append("DVPAssistMatchup")
    
    # NOVAS TESES
    if tese_steal_explosion(p,game_ctx,{}):
        tags.append("StealPotential")
    
    if tese_block_explosion(p,game_ctx,{}):
        tags.append("BlockPotential")
    
    if tese_three_point_potential(p,game_ctx,{}):
        tags.append("ThreePointPotential")
    
    if tese_ceiling_explosion(p,game_ctx,{}):
        tags.append("CeilingExplosion")
    
    return tags

# ============================================================================
# FUNÇÕES DE SCORING
# ============================================================================

# ============================================================================
# FUNÇÕES DE SCORING QUE ESTAVAM FALTANDO
# ============================================================================
# [código existente das funções de scoring]

# ============================================================================
# NOVAS FUNÇÕES DE EXIBIÇÃO ESTRATÉGICA
# ============================================================================
def display_player_theses(player_ctx, game_ctx):
    """Exibe as teses geradas para um jogador"""
    if "thesis_engine" not in st.session_state:
        return
    
    try:
        theses = st.session_state.thesis_engine.generate_all_theses(player_ctx, game_ctx)
        
        if theses:
            st.markdown("**🔍 Teses Estratégicas:**")
            for thesis in theses:
                confidence_color = "#10B981" if thesis["confidence"] >= 0.7 else "#F59E0B" if thesis["confidence"] >= 0.5 else "#EF4444"
                confidence_badge = f'<span style="color: {confidence_color}; font-weight: bold;">{thesis["confidence"]:.2f}</span>'
                
                st.markdown(f"""
                <div style="padding: 8px; border-left: 3px solid {confidence_color}; margin: 4px 0; background: rgba(255,255,255,0.05);">
                    <strong>{thesis['thesis_type']}</strong> ({thesis['market']}) - Confiança: {confidence_badge}<br>
                    <small>{thesis['reason']}</small><br>
                    <small><strong>Evidências:</strong> {', '.join(thesis['evidences'])}</small>
                </div>
                """, unsafe_allow_html=True)
                
                # Mostrar linha sugerida se disponível
                if thesis.get('suggested_line'):
                    st.markdown(f"<small>📊 Linha sugerida: {thesis['suggested_line']}</small>", unsafe_allow_html=True)
        
        else:
            st.caption("Nenhuma tese estratégica identificada")
    
    except Exception as e:
        st.error(f"Erro ao gerar teses: {e}")


def score_player_for_main_trixie_dynamic(p, game_ctx):
    """
    Função de scoring dinâmico para trixies main.
    Versão dinâmica que ajusta thresholds baseado no contexto.
    """
    # Usar a função enhanced como base e adicionar ajustes dinâmicos
    base_score = score_player_for_main_trixie_enhanced(p, game_ctx)
    
    # Ajustes dinâmicos baseados em contexto
    dynamic_adjustments = 0.0
    
    # 1. Ajuste por ritmo do jogo
    if game_ctx.get("pace_expected"):
        if game_ctx["pace_expected"] > 102:
            # Jogo de ritmo alto - favorece estatísticas ofensivas
            if p.get("position") in ["PG", "SG"]:
                dynamic_adjustments += 2.0
        elif game_ctx["pace_expected"] < 98:
            # Jogo de ritmo baixo - favorece rebotes
            if p.get("position") in ["C", "PF"]:
                dynamic_adjustments += 1.5
    
    # 2. Ajuste por spread
    spread = game_ctx.get("spread")
    if spread:
        try:
            spread_val = abs(float(spread))
            if spread_val >= 10:  # Alto risco de blowout
                # Penalizar jogadores veteranos em times favoritos
                if not p.get("is_underdog", False) and p.get("is_veteran", False):
                    dynamic_adjustments -= 3.0
                # Beneficiar jogadores jovens em times underdog
                elif p.get("is_underdog", False) and p.get("is_young", False):
                    dynamic_adjustments += 2.0
        except:
            pass
    
    # 3. Ajuste por total do jogo
    total = game_ctx.get("total")
    if total:
        try:
            total_val = float(total)
            if total_val > 230:  # Jogo de alta pontuação
                # Beneficiar jogadores com alta média de pontos
                if p.get("pts_L5", 0) > 15:
                    dynamic_adjustments += 1.5
        except:
            pass
    
    # 4. Ajuste por injuries do time
    if p.get("team_injuries", 0) >= 2:
        # Mais opportunities devido a lesões
        if p.get("role") in ["rotation", "bench_scorer"]:
            dynamic_adjustments += 2.0
    
    return base_score + dynamic_adjustments


def score_player_for_upside_trixie(p, game_ctx):
    """
    Scoring para trixies upside (potencial de explosão).
    """
    base = 0.0
    
    # Foco em potencial de crescimento vs média
    pra_L5 = p.get("pra_L5", 0)
    if "proj_ceil_95_pra" in p:
        ceiling = p.get("proj_ceil_95_pra", pra_L5)
        upside_ratio = ceiling / pra_L5 if pra_L5 > 0 else 1.0
        base += upside_ratio * 15.0
    
    # Uso recente crescente
    if p.get("usage_spike", False):
        base += 8.0
    
    # Jogador jovem com minutos crescentes
    if p.get("is_young", False) and p.get("min_L5", 0) > p.get("min_L10", 0):
        base += 6.0
    
    # Situação de lesões no time
    if p.get("team_injuries", 0) >= 1:
        base += 5.0
    
    # Matchup DvP favorável
    dvp_data = p.get("dvp_data", {})
    if dvp_data:
        overall = dvp_data.get("overall", 1.0)
        if overall > 1.05:
            base += (overall - 1.0) * 30
    
    # Volatilidade controlada (um pouco de volatilidade é bom para upside)
    volatility = p.get("volatility", "medium")
    if volatility == "medium":
        base += 3.0
    elif volatility == "high":
        base += 1.0  # Um pouco menos, muito risco
    
    # Underdog status
    if p.get("is_underdog", False):
        base += 4.0
    
    return base


def score_player_for_highvalue_trixie(p, game_ctx):
    """
    Scoring para trixies highvalue (valor consistente).
    """
    base = 0.0
    
    # Consistência é chave
    min_cv = p.get("min_cv", 1.0)
    if min_cv < 0.3:
        base += 12.0
    elif min_cv < 0.5:
        base += 8.0
    elif min_cv < 0.7:
        base += 4.0
    
    # Estatísticas por minuto
    reb_per_min = p.get("reb_per_min", 0)
    ast_per_min = p.get("ast_per_min", 0)
    
    if reb_per_min >= 0.25:
        base += 10.0
    elif reb_per_min >= 0.2:
        base += 6.0
    elif reb_per_min >= 0.15:
        base += 3.0
    
    if ast_per_min >= 0.2:
        base += 10.0
    elif ast_per_min >= 0.15:
        base += 6.0
    elif ast_per_min >= 0.1:
        base += 3.0
    
    # Valor de mercado vs produção
    pra_L5 = p.get("pra_L5", 0)
    min_L5 = p.get("min_L5", 0)
    
    if min_L5 > 0:
        pra_per_min = pra_L5 / min_L5
        if pra_per_min >= 1.2:
            base += 15.0
        elif pra_per_min >= 1.0:
            base += 10.0
        elif pra_per_min >= 0.8:
            base += 5.0
    
    # DvP consistente (não precisa ser excelente, apenas bom)
    dvp_data = p.get("dvp_data", {})
    if dvp_data:
        rankings = dvp_data.get("rankings", {})
        
        # Verificar se todas as estatísticas têm rank <= 15 (top half)
        all_good = True
        for metric in ["points", "rebounds", "assists"]:
            rank = rankings.get(metric, {}).get("rank", 30)
            if rank > 15:
                all_good = False
                break
        
        if all_good:
            base += 8.0
    
    # Não penalizar volatilidade baixa
    volatility = p.get("volatility", "medium")
    if volatility == "low":
        base += 5.0
    
    return base


def score_player_for_boost_mode(p, game_ctx):
    score = 0.0

    # Rebotes: bigs dominantes
    reb = p.get("proj_ceil_95_reb", 0) or 0
    reb_base = p.get("reb_L5", 0) or 0
    if reb > reb_base * 1.2:
        score += 2.5

    # Assistências: guards criadores
    ast = p.get("proj_ceil_95_ast", 0) or 0
    ast_base = p.get("ast_L5", 0) or 0
    if ast > ast_base * 1.2:
        score += 2.5

    # 3PM: especialistas
    three = p.get("proj_ceil_95_3pm", 0) or 0
    three_base = p.get("3pm_L5", 0) or 0
    if three > three_base * 1.2:
        score += 2.0

    # Steals e Blocks: raros, alto impacto
    stl = p.get("proj_ceil_95_stl", 0) or 0
    stl_base = p.get("stl_L5", 0) or 0
    if stl > stl_base * 1.2:
        score += 3.0

    blk = p.get("proj_ceil_95_blk", 0) or 0
    blk_base = p.get("blk_L5", 0) or 0
    if blk > blk_base * 1.2:
        score += 3.0

    # Ajuste de contexto: underdog em jogo de pace alto
    pace = float(game_ctx.get("pace_expected") or 0)
    if p.get("is_underdog", False) and pace > 102:
        score += 1.5

    return score

  
    # 1. CEILING EXPLOSION (peso máximo)
    if "proj_ceil_95_pra" in p:
        ceiling_pra = p.get("proj_ceil_95_pra", 0)
        baseline_pra = p.get("pra_L5", 0)
        
        if baseline_pra > 0:
            ceiling_ratio = ceiling_pra / baseline_pra
            # Ratio muito alto = maior potencial
            if ceiling_ratio >= 1.5:
                score += 30.0
            elif ceiling_ratio >= 1.3:
                score += 20.0
            elif ceiling_ratio >= 1.2:
                score += 12.0
            elif ceiling_ratio >= 1.1:
                score += 6.0
    
    # 2. STATS EXPLOSIVAS (roubos, tocos, 3 pontos)
    # Steal Potential
    stl_avg = p.get("stl_L5", 0)
    if stl_avg >= 2.0:
        score += 25.0
    elif stl_avg >= 1.5:
        score += 18.0
    elif stl_avg >= 1.0:
        score += 10.0
    elif stl_avg >= 0.8:
        score += 5.0
    
    # Block Potential
    blk_avg = p.get("blk_L5", 0)
    if blk_avg >= 2.0:
        score += 25.0
    elif blk_avg >= 1.5:
        score += 18.0
    elif blk_avg >= 1.0:
        score += 10.0
    elif blk_avg >= 0.8:
        score += 5.0
    
    # Three Point Potential
    threes_avg = p.get("3pm_L5", 0)
    if threes_avg >= 3.5:
        score += 20.0
    elif threes_avg >= 2.5:
        score += 15.0
    elif threes_avg >= 1.5:
        score += 8.0
    elif threes_avg >= 1.0:
        score += 4.0

    # 3. BÔNUS POR MÚLTIPLAS STATS EXPLOSIVAS
    explosive_stats = 0
    if stl_avg >= 1.0: explosive_stats += 1
    if blk_avg >= 1.0: explosive_stats += 1
    if threes_avg >= 1.5: explosive_stats += 1

    if explosive_stats >= 3:
        score += 15.0  # Triple Threat explosivo
    elif explosive_stats >= 2:
        score += 8.0   # Double Threat

    
    # 3. FATORES CONTEXTUAIS (BOOST MODE)
    pace = game_ctx.get("pace_expected") or 100
    if pace > 102:
        score += 6.0
    elif pace > 100:
        score += 3.0
    
    # Underdog em jogo de ritmo alto
    if p.get("is_underdog", False) and pace > 102:
        score += 4.0
    
    # Usage Spike (mais oportunidades)
    if p.get("usage_spike", False):
        score += 5.0
    
    # Lesões no time (mais oportunidades)
    if p.get("team_injuries", 0) >= 2:
        base += 6.0
    
    # 5. DvP MUITO FAVORÁVEL
    dvp_data = p.get("dvp_data", {})
    if dvp_data:
        overall = dvp_data.get("overall", 1.0)
        if overall >= 1.15:
            score += 12.0
        elif overall >= 1.1:
            score += 8.0
        elif overall >= 1.05:
            score += 4.0
    
    # 6. VOLATILIDADE ALTA = BOM PARA BOOST
    volatility = p.get("volatility", "medium")
    if volatility == "high":
        score += 8.0
    elif volatility == "medium":
        score += 4.0
    
    # 7. BÔNUS POR POSIÇÃO ESPECÍFICA COM POTENCIAL
    position = p.get("position", "").upper()
    if position in ["PG", "SG"] and ast_avg >= 6.0:
        score += 3.0  # Playmaker com alto potencial de assists
    elif position in ["C", "PF"] and reb_avg >= 9.0:
        score += 3.0  # Big com alto potencial de rebotes
    
    return base

# ============================================================================
# ESCOLHER MERCADO (atualizada para usar trixie_type)
# ============================================================================

def escolher_mercado_para_jogador_tipo(p, tags, trixie_type="main"):
    return escolher_mercado_para_jogador(p, tags, trixie_type)

# ============================================================================
# GAME CONTEXT
# ============================================================================

def build_game_context(away_abbr, home_abbr, odds_map, team_advanced, team_opponent):
    away_full = TEAM_ABBR_TO_ODDS.get(away_abbr); home_full = TEAM_ABBR_TO_ODDS.get(home_abbr)
    odds = {}
    if away_full and home_full:
        key_full = f"{away_full}@{home_full}"
        odds = odds_map.get(key_full, {}) if odds_map else {}
    spread = odds.get("spread"); total = odds.get("total")
    adv_home = team_advanced.get(home_abbr, {}) if team_advanced else {}
    adv_away = team_advanced.get(away_abbr, {}) if team_advanced else {}
    pace_home = adv_home.get("pace", None); pace_away = adv_away.get("pace", None)
    try:
        pace_expected = (float(pace_home)+float(pace_away))/2.0 if (pace_home is not None and pace_away is not None) else None
    except Exception:
        pace_expected = None
    ctx = {"away_abbr": away_abbr, "home_abbr": home_abbr, "away_full": away_full, "home_full": home_full,
           "spread": spread, "total": total, "pace_expected": pace_expected}
    return ctx

def classify_game_script(game_ctx):
    total = game_ctx.get("total"); spread = game_ctx.get("spread"); pace = game_ctx.get("pace_expected")
    pace_tag="PACE_NEUTRO"; total_tag="TOTAL_NEUTRO"; blowout_tag="JOGO_EQUILIBRADO"
    if pace is not None:
        try:
            p=float(pace)
            if p>100: pace_tag="PACE_ALTO"
            elif p<97: pace_tag="PACE_BAIXO"
        except Exception: pass
    if total is not None:
        try:
            t=float(total)
            if t>232: total_tag="TOTAL_ALTO"
            elif t<220: total_tag="TOTAL_BAIXO"
        except Exception: pass
    try:
        s_abs = abs(float(spread or 0.0))
        if s_abs>=10: blowout_tag="RISCO_BLOWOUT_ALTO"
        elif s_abs>=6: blowout_tag="RISCO_BLOWOUT_MEDIO"
        else: blowout_tag="JOGO_EQUILIBRADO"
    except Exception: pass
    script_type = f"{pace_tag}_{total_tag}_{blowout_tag}"
    notes=[]
    notes.append("Ritmo alto, bom para PTS/AST/PRA." if pace_tag=="PACE_ALTO" else ("Ritmo baixo, bom para REB, menos posses." if pace_tag=="PACE_BAIXO" else "Ritmo neutro."))
    notes.append("Total alto, favorece volume ofensivo." if total_tag=="TOTAL_ALTO" else ("Total baixo, jogo mais travado." if total_tag=="TOTAL_BAIXO" else ""))
    notes.append("Alto risco de garbage time." if blowout_tag=="RISCO_BLOWOUT_ALTO" else ("Médio risco de blowout." if blowout_tag=="RISCO_BLOWOUT_MEDIO" else "Jogo tende a se manter próximo."))
    return script_type, " ".join([n for n in notes if n])

# ============================================================================
# FUNÇÕES DE SCORING ATUALIZADAS
# ============================================================================

def score_player_for_main_trixie_enhanced(p, game_ctx):
    base = 0.0
    # ... (código existente permanece igual)

def score_player_for_main_trixie_dynamic(p, game_ctx):
    """
    Função de scoring dinâmico para trixies main.
    Versão dinâmica que ajusta thresholds baseado no contexto.
    """
    # Usar a função enhanced como base e adicionar ajustes dinâmicos
    base_score = score_player_for_main_trixie_enhanced(p, game_ctx)
    
    # Ajustes dinâmicos baseados em contexto
    dynamic_adjustments = 0.0
    
    # 1. Ajuste por ritmo do jogo
    if game_ctx.get("pace_expected"):
        if game_ctx["pace_expected"] > 102:
            # Jogo de ritmo alto - favorece estatísticas ofensivas
            if p.get("position") in ["PG", "SG"]:
                dynamic_adjustments += 2.0
        elif game_ctx["pace_expected"] < 98:
            # Jogo de ritmo baixo - favorece rebotes
            if p.get("position") in ["C", "PF"]:
                dynamic_adjustments += 1.5
    
    # 2. Ajuste por spread
    spread = game_ctx.get("spread")
    if spread:
        try:
            spread_val = abs(float(spread))
            if spread_val >= 10:  # Alto risco de blowout
                # Penalizar jogadores veteranos em times favoritos
                if not p.get("is_underdog", False) and p.get("is_veteran", False):
                    dynamic_adjustments -= 3.0
                # Beneficiar jogadores jovens em times underdog
                elif p.get("is_underdog", False) and p.get("is_young", False):
                    dynamic_adjustments += 2.0
        except:
            pass
    
    # 3. Ajuste por total do jogo
    total = game_ctx.get("total")
    if total:
        try:
            total_val = float(total)
            if total_val > 230:  # Jogo de alta pontuação
                # Beneficiar jogadores com alta média de pontos
                if p.get("pts_L5", 0) > 15:
                    dynamic_adjustments += 1.5
        except:
            pass
    
    # 4. Ajuste por injuries do time
    if p.get("team_injuries", 0) >= 2:
        # Mais opportunities devido a lesões
        if p.get("role") in ["rotation", "bench_scorer"]:
            dynamic_adjustments += 2.0

    return float(base_score or 0.0) + float(dynamic_adjustments or 0.0)


def score_player_for_upside_trixie(p, game_ctx):
    """
    Scoring para trixies upside (potencial de explosão).
    """
    base = 0.0
    
    # Foco em potencial de crescimento vs média
    pra_L5 = p.get("pra_L5", 0)
    if "proj_ceil_95_pra" in p:
        ceiling = p.get("proj_ceil_95_pra", pra_L5)
        upside_ratio = ceiling / pra_L5 if pra_L5 > 0 else 1.0
        base += upside_ratio * 15.0
    
    # Uso recente crescente
    if p.get("usage_spike", False):
        base += 8.0
    
    # Jogador jovem com minutos crescentes
    if p.get("is_young", False) and p.get("min_L5", 0) > p.get("min_L10", 0):
        base += 6.0
    
    # Situação de lesões no time
    if p.get("team_injuries", 0) >= 1:
        base += 5.0
    
    # Matchup DvP favorável
    dvp_data = p.get("dvp_data", {})
    if dvp_data:
        overall = dvp_data.get("overall", 1.0)
        if overall > 1.05:
            base += (overall - 1.0) * 30
    
    # Volatilidade controlada (um pouco de volatilidade é bom para upside)
    volatility = p.get("volatility", "medium")
    if volatility == "medium":
        base += 3.0
    elif volatility == "high":
        base += 1.0  # Um pouco menos, muito risco
    
    # Underdog status
    if p.get("is_underdog", False):
        base += 4.0
    
    return base


def score_player_for_highvalue_trixie(p, game_ctx):
    """
    Scoring para trixies highvalue (valor consistente).
    """
    base = 0.0
    
    # Consistência é chave
    min_cv = p.get("min_cv", 1.0)
    if min_cv < 0.3:
        base += 12.0
    elif min_cv < 0.5:
        base += 8.0
    elif min_cv < 0.7:
        base += 4.0
    
    # Estatísticas por minuto
    reb_per_min = p.get("reb_per_min", 0)
    ast_per_min = p.get("ast_per_min", 0)
    
    if reb_per_min >= 0.25:
        base += 10.0
    elif reb_per_min >= 0.2:
        base += 6.0
    elif reb_per_min >= 0.15:
        base += 3.0
    
    if ast_per_min >= 0.2:
        base += 10.0
    elif ast_per_min >= 0.15:
        base += 6.0
    elif ast_per_min >= 0.1:
        base += 3.0
    
    # Valor de mercado vs produção
    pra_L5 = p.get("pra_L5", 0)
    min_L5 = p.get("min_L5", 0)
    
    if min_L5 > 0:
        pra_per_min = pra_L5 / min_L5
        if pra_per_min >= 1.2:
            base += 15.0
        elif pra_per_min >= 1.0:
            base += 10.0
        elif pra_per_min >= 0.8:
            base += 5.0
    
    # DvP consistente (não precisa ser excelente, apenas bom)
    dvp_data = p.get("dvp_data", {})
    if dvp_data:
        rankings = dvp_data.get("rankings", {})
        
        # Verificar se todas as estatísticas têm rank <= 15 (top half)
        all_good = True
        for metric in ["points", "rebounds", "assists"]:
            rank = rankings.get(metric, {}).get("rank", 30)
            if rank > 15:
                all_good = False
                break
        
        if all_good:
            base += 8.0
    
    # Não penalizar volatilidade baixa
    volatility = p.get("volatility", "medium")
    if volatility == "low":
        base += 5.0
    
    return base


def score_player_for_boost_mode(p, game_ctx):
    """
    Scoring específico para Boost Mode (foco em tetos explosivos).
    """
    base = 0.0
    
    # 1. CEILING EXPLOSION (peso máximo)
    if "proj_ceil_95_pra" in p:
        ceiling_pra = p.get("proj_ceil_95_pra", 0)
        baseline_pra = p.get("pra_L5", 0)
        
        if baseline_pra > 0:
            ceiling_ratio = ceiling_pra / baseline_pra
            
            # Ratio muito alto = maior potencial
            if ceiling_ratio >= 1.5:
                base += 25.0
            elif ceiling_ratio >= 1.3:
                base += 18.0
            elif ceiling_ratio >= 1.2:
                base += 12.0
            elif ceiling_ratio >= 1.1:
                base += 6.0
    
    # 2. STATS EXPLOSIVAS (roubos, tocos, 3 pontos)
    # Steal Potential
    stl_avg = p.get("stl_L5", 0)
    if stl_avg >= 2.0:
        base += 15.0
    elif stl_avg >= 1.5:
        base += 10.0
    elif stl_avg >= 1.0:
        base += 5.0
    
    # Block Potential
    blk_avg = p.get("blk_L5", 0)
    if blk_avg >= 2.0:
        base += 15.0
    elif blk_avg >= 1.5:
        base += 10.0
    elif blk_avg >= 1.0:
        base += 5.0
    
    # Three Point Potential
    threes_avg = p.get("3pm_L5", 0)
    if threes_avg >= 3.5:
        base += 12.0
    elif threes_avg >= 2.5:
        base += 8.0
    elif threes_avg >= 1.5:
        base += 4.0
    
    # 3. FATORES CONTEXTUAIS (BOOST MODE)
    # Ritmo alto do jogo
    pace = game_ctx.get("pace_expected") or 0
    if pace > 102:
        base += 8.0
    
    # Underdog em jogo de ritmo alto
    pace = float(game_ctx.get("pace_expected") or 0)
    if p.get("is_underdog", False) and pace > 102:
        base += 6.0
    
    # Usage Spike
    if p.get("usage_spike", False):
        base += 7.0
    
    # Lesões no time (mais oportunidades)
    if p.get("team_injuries", 0) >= 2:
        base += 6.0
    
    # DvP muito favorável (overall > 1.1)
    dvp_data = p.get("dvp_data", {})
    if dvp_data:
        overall = dvp_data.get("overall", 1.0)
        if overall >= 1.15:
            base += 10.0
        elif overall >= 1.1:
            base += 6.0
        elif overall >= 1.05:
            base += 3.0
    
    # Volatilidade ALTA é BOA para Boost Mode (maior potencial de explosão)
    volatility = p.get("volatility", "medium")
    if volatility == "high":
        base += 8.0
    elif volatility == "medium":
        base += 4.0
    
    # Posições com maior potencial explosivo
    position = p.get("position", "").upper()
    if position in ["PG", "SG"]:  # Guards têm mais potencial para assists e steals
        base += 4.0
    elif position in ["PF", "C"]:  # Bigs têm mais potencial para blocks e rebounds
        base += 3.0
    
    return base
# ============================================================================
# BUILD TRIXIES ORIGINAIS
# ============================================================================

def build_trixies_for_game_main(team_players_ctx, game_ctx):
    all_players=[]
    for _, plist in team_players_ctx.items():
        for p in plist:
            if p.get("expected_minutes",0)<24: continue
            if p.get("mercado") is None: continue
            all_players.append(p)
    if len(all_players)<3: return []
    scored = [(score_player_for_main_trixie_dynamic(p, game_ctx), p) for p in all_players]  # Usar versão dinâmica
    scored.sort(key=lambda x: x[0], reverse=True)
    top_players = [p for s,p in scored[:12]]
    trixies=[]
    for trio in combinations(top_players, 3):
        teams = {p["team"] for p in trio}
        if len(teams)<2: continue
        score_trio = sum(score_player_for_main_trixie_dynamic(p, game_ctx) for p in trio)  # Usar versão dinâmica
        trixies.append({"players": trio, "score": score_trio})
    trixies.sort(key=lambda x: x["score"], reverse=True)
    return trixies[:PERFORMANCE_CONFIG["max_trixies_per_game"]["main"]]

def build_trixies_for_game_upside(team_players_ctx, game_ctx):
    candidates=[]
    for _, plist in team_players_ctx.items():
        for p in plist:
            if p.get("mercado") is None: continue
            tags = p.get("tags", [])
            if not any(t in UPSIDE_TESES for t in tags):
                continue
            if p.get("pra_L5",0)<10: continue
            candidates.append(p)
    if len(candidates)<3: return []
    scored = [(score_player_for_upside_trixie(p, game_ctx), p) for p in candidates]
    scored.sort(key=lambda x: x[0], reverse=True)
    top_players = [p for s,p in scored[:12]]
    trixies=[]
    for trio in combinations(top_players, 3):
        teams = {p["team"] for p in trio}
        if len(teams)<2: continue
        score_trio = sum(score_player_for_upside_trixie(p, game_ctx) for p in trio)
        trixies.append({"players": trio, "score": score_trio})
    trixies.sort(key=lambda x: x["score"], reverse=True)
    return trixies[:PERFORMANCE_CONFIG["max_trixies_per_game"]["upside"]]

def build_trixies_for_game_highvalue(team_players_ctx, game_ctx):
    candidates=[]
    for _, plist in team_players_ctx.items():
        for p in plist:
            if p.get("mercado") is None: continue
            tags = p.get("tags", [])
            if not any(t in HIGHVALUE_TESES for t in tags):
                continue
            if p.get("pra_L5",0) < 8: continue
            if p.get("expected_minutes",0) < 15: continue
            candidates.append(p)
    
    if len(candidates)<3: return []
    
    scored = [(score_player_for_highvalue_trixie(p, game_ctx), p) for p in candidates]
    scored.sort(key=lambda x: x[0], reverse=True)
    top_players = [p for s,p in scored[:10]]
    
    trixies=[]
    for trio in combinations(top_players, 3):
        teams = {p["team"] for p in trio}
        if len(teams)<2: continue
        score_trio = sum(score_player_for_highvalue_trixie(p, game_ctx) for p in trio)
        trixies.append({"players": trio, "score": score_trio})
    
    trixies.sort(key=lambda x: x["score"], reverse=True)
    return trixies[:PERFORMANCE_CONFIG["max_trixies_per_game"]["highvalue"]]

# ============================================================================
# NOVO: FUNÇÃO PARA BOOST MODE (FASE 4.2)
# ============================================================================
def build_trixies_for_game_boost(team_players_ctx, game_ctx):
    """Gera trixies para Boost Mode (foco em tetos explosivos de stats individuais)"""
    candidates = []
    for _, plist in team_players_ctx.items():
        for p in plist:
            tags = p.get("tags", [])
            has_potential = any(t in BOOST_TESES for t in tags)

            # Critério de teto explosivo em stats específicos
            has_high_ceiling = False
            for stat in ["reb", "ast", "3pm", "stl", "blk"]:
                ceil = p.get(f"proj_ceil_95_{stat}", 0) or 0
                base = p.get(f"{stat}_L5", 0) or 0
                # mais flexível: 20% acima da média recente já conta
                if ceil > base * 1.2 and ceil >= base + 2:
                    has_high_ceiling = True
                    break

            # Critério final de inclusão
            if has_potential or has_high_ceiling:
                if (p.get("expected_minutes") or 0) >= 12:  # reduzimos para 12
                    candidates.append(p)

        # fallback: se nenhum candidato no time, força o melhor teto
        if not candidates and plist:
            best = max(plist, key=lambda x: x.get("proj_ceil_95_reb", 0) +
                                      x.get("proj_ceil_95_ast", 0) +
                                      x.get("proj_ceil_95_3pm", 0) +
                                      x.get("proj_ceil_95_stl", 0) +
                                      x.get("proj_ceil_95_blk", 0))
            candidates.append(best)

    if len(candidates) < 3:
        return []

    # Score com função específica
    scored = [(score_player_for_boost_mode(p, game_ctx), p) for p in candidates]
    scored.sort(key=lambda x: x[0], reverse=True)
    top_players = [p for s, p in scored[:15]]  # mais jogadores para combinações

    trixies = []
    for trio in combinations(top_players, 3):
        teams = {p["team"] for p in trio}
        if len(teams) < 2:
            continue

        positions = [p.get("position", "").upper() for p in trio]
        guards = sum(1 for pos in positions if pos in ["PG", "SG"])
        bigs = sum(1 for pos in positions if pos in ["PF", "C"])

        # ✅ calcula primeiro
        score_trio = sum(score_player_for_boost_mode(p, game_ctx) for p in trio)

        # ✅ penaliza depois
        if guards == 0 or bigs == 0:
            score_trio -= 2.0

        trixies.append({
            "players": trio,
            "score": score_trio,
            "type": "boost"
        })

    trixies.sort(key=lambda x: x["score"], reverse=True)
    return trixies[:PERFORMANCE_CONFIG["max_trixies_per_game"]["boost"]]

# ============================================================================
# SISTEMA DE AUDITORIA COMPLETO
# ============================================================================

def fetch_espn_boxscore(game_id):
    """
    Busca o boxscore de um jogo da ESPN.
    
    Args:
        game_id: ID do jogo na ESPN
    
    Returns:
        Dicionário com as estatísticas do jogo, ou None se não encontrado.
    """
    params = {"event": game_id}
    
    try:
        response = requests.get(ESPN_BOXSCORE_URL, params=params, headers=HEADERS, timeout=10)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        st.error(f"Erro ao buscar boxscore da ESPN: {e}")
        return None

class AuditSystem:
    """
    Sistema de auditoria para rastrear e validar todas as trixies geradas.
    """
    
    def __init__(self, cache_file=None):
        self.cache_file = cache_file or AUDIT_CACHE_FILE
        self.audit_data = self._load_audit_data()
    
    def _load_audit_data(self):
        """Carrega dados de auditoria do cache"""
        try:
            if os.path.exists(self.cache_file):
                with open(self.cache_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception:
            pass
        return []
    
    def _save_audit_data(self):
        """Salva dados de auditoria no cache"""
        try:
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(self.audit_data, f, indent=2, ensure_ascii=False)
        except Exception:
            pass
    
    def log_trixie(self, trixie, game_info, trixie_type, source="system"):
        """
        Registra uma trixie na auditoria.
        
        Args:
            trixie: Dicionário da trixie
            game_info: Informações do jogo
            trixie_type: Tipo de trixie
            source: Fonte da trixie
        """
        audit_entry = {
            "id": f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{hash(str(trixie))}",
            "timestamp": datetime.now().isoformat(),
            "date": TODAY,
            "game": game_info,
            "trixie_type": trixie_type,
            "score": trixie.get("score", 0),
            "enhanced": trixie.get("enhanced", False),
            "source": source,
            "players": []
        }
        
        for p in trixie.get("players", []):
            player_entry = {
                "name": p.get("name"),
                "team": p.get("team"),
                "position": p.get("position"),
                "mercado": p.get("mercado", {}),
                "tese_efetiva": p.get("tese_efetiva", ""),  # Nova informação
                "stats": {
                    "min_L5": p.get("min_L5", 0),
                    "pts_L5": p.get("pts_L5", 0),
                    "reb_L5": p.get("reb_L5", 0),
                    "ast_L5": p.get("ast_L5", 0),
                    "pra_L5": p.get("pra_L5", 0),
                    "stl_L5": p.get("stl_L5", 0) if "stl_L5" in p else 0,
                    "blk_L5": p.get("blk_L5", 0) if "blk_L5" in p else 0,
                    "3pm_L5": p.get("3pm_L5", 0) if "3pm_L5" in p else 0
                },
                "tags": p.get("tags", []),
                "dvp_data": p.get("dvp_data", {})
            }
            audit_entry["players"].append(player_entry)
        
        self.audit_data.append(audit_entry)
        
        # Manter apenas os últimos 1000 registros
        if len(self.audit_data) > 1000:
            self.audit_data = self.audit_data[-1000:]
        
        self._save_audit_data()
    
    def validate_trixie_with_boxscore(self, audit_entry):
        """
        Valida uma trixie com base nos dados reais do jogo (boxscore).
        
        Args:
            audit_entry: Entrada de auditoria
        
        Returns:
            A mesma entrada com validação atualizada
        """
        game_info = audit_entry.get("game", {})
        game_id = game_info.get("gameId")
        
        if not game_id:
            return audit_entry
        
        # Buscar boxscore
        boxscore = fetch_espn_boxscore(game_id)
        if not boxscore:
            return audit_entry
        
        # Inicializar estrutura de validação
        validation = {
            "validated": True,
            "validation_date": datetime.now().isoformat(),
            "game_id": game_id,
            "players": [],
            "overall": "UNKNOWN"
        }
        
        all_green = True
        any_red = False
        
        for player in audit_entry.get("players", []):
            player_name = player.get("name")
            player_team = player.get("team")
            mercado = player.get("mercado", {})
            
            # Buscar estatísticas do jogador no boxscore
            player_stats = self._extract_player_stats_from_boxscore(boxscore, player_name, player_team)
            
            if not player_stats:
                # Jogador não encontrado no boxscore (não jogou?)
                player_validation = {
                    "name": player_name,
                    "team": player_team,
                    "found": False,
                    "status": "NO_DATA",
                    "target": mercado.get("base_valor", 0),
                    "actual": 0
                }
                all_green = False
            else:
                # Verificar se a leg foi GREEN ou RED
                leg_type = mercado.get("tipo")
                target_value = mercado.get("base_valor", 0)
                
                # Mapear tipo de leg para estatística do boxscore
                stat_mapping = {
                    "PTS": "points",
                    "REB": "rebounds", 
                    "AST": "assists",
                    "PRA": "pra",
                    "STL": "steals",
                    "BLK": "blocks",
                    "3PM": "three_pointers"
                }
                
                stat_key = stat_mapping.get(leg_type, "points")
                actual_value = player_stats.get(stat_key, 0)
                
                if leg_type == "PRA":
                    actual_value = player_stats.get("points", 0) + player_stats.get("rebounds", 0) + player_stats.get("assists", 0)
                
                # Determinar status
                if actual_value >= target_value:
                    status = "GREEN"
                else:
                    status = "RED"
                    all_green = False
                    any_red = True
                
                player_validation = {
                    "name": player_name,
                    "team": player_team,
                    "found": True,
                    "status": status,
                    "target": target_value,
                    "actual": actual_value,
                    "stats": player_stats,
                    "leg_type": leg_type
                }
            
            validation["players"].append(player_validation)
        
        # Determinar status geral da trixie
        if all_green:
            validation["overall"] = "GREEN"
        elif any_red:
            validation["overall"] = "RED"
        else:
            validation["overall"] = "PARTIAL"
        
        audit_entry["validation"] = validation
        return audit_entry
    
    def _extract_player_stats_from_boxscore(self, boxscore, player_name, team_abbr):
        """
        Extrai as estatísticas de um jogador do boxscore da ESPN.
        
        Args:
            boxscore: Dicionário do boxscore da ESPN
            player_name: Nome do jogador
            team_abbr: Abreviação do time
        
        Returns:
            Dicionário com as estatísticas ou None se não encontrado
        """
        try:
            # A estrutura do boxscore da ESPN varia
            # Vamos procurar em diferentes locais
            players_data = []
            
            # Tentar obter jogadores do boxscore
            if "boxscore" in boxscore:
                teams = boxscore["boxscore"].get("teams", [])
                for team in teams:
                    team_players = team.get("statistics", [])
                    for player in team_players:
                        athlete = player.get("athlete", {})
                        name = athlete.get("displayName", "")
                        if normalize_name(name) == normalize_name(player_name):
                            # Extrair estatísticas
                            stats = {}
                            for stat in player.get("stats", []):
                                if "name" in stat and "value" in stat:
                                    stats[stat["name"].lower()] = float(stat["value"])
                            
                            # Mapear nomes comuns
                            mapped_stats = {
                                "points": stats.get("points", 0),
                                "rebounds": stats.get("rebounds", stats.get("reb", 0)),
                                "assists": stats.get("assists", stats.get("ast", 0)),
                                "minutes": stats.get("minutes", stats.get("min", 0)),
                                "steals": stats.get("steals", stats.get("stl", 0)),
                                "blocks": stats.get("blocks", stats.get("blk", 0)),
                                "turnovers": stats.get("turnovers", stats.get("to", 0)),
                                "three_pointers": stats.get("3pt", stats.get("three_pointers", 0))
                            }
                            return mapped_stats
            
            return None
        except Exception:
            return None
    
    def get_audit_data(self, date_filter=None, trixie_type_filter=None, team_filter=None, status_filter=None):
        """
        Obtém dados de auditoria filtrados.
        
        Args:
            date_filter: Filtrar por data (YYYY-MM-DD)
            trixie_type_filter: Filtrar por tipo de trixie
            team_filter: Filtrar por time
            status_filter: Filtrar por status ("GREEN", "RED", "PARTIAL")
        
        Returns:
            Lista de entradas de auditoria filtradas
        """
        filtered = self.audit_data
        
        if date_filter:
            filtered = [entry for entry in filtered if entry.get("date") == date_filter]
        
        if trixie_type_filter:
            filtered = [entry for entry in filtered if entry.get("trixie_type") == trixie_type_filter]
        
        if team_filter:
            filtered = [
                entry for entry in filtered 
                if any(p.get("team") == team_filter for p in entry.get("players", []))
            ]
        
        if status_filter:
            filtered_with_validation = []
            for entry in filtered:
                if "validation" in entry:
                    if entry["validation"].get("overall") == status_filter:
                        filtered_with_validation.append(entry)
                elif status_filter == "UNKNOWN":
                    filtered_with_validation.append(entry)
            filtered = filtered_with_validation
        
        return filtered
    
    def get_validation_stats(self):
        """
        Retorna estatísticas de validação.
        
        Returns:
            Dicionário com estatísticas
        """
        stats = {
            "total": len(self.audit_data),
            "validated": 0,
            "green": 0,
            "red": 0,
            "partial": 0,
            "unknown": 0
        }
        
        for entry in self.audit_data:
            if "validation" in entry:
                stats["validated"] += 1
                overall = entry["validation"].get("overall", "UNKNOWN")
                if overall == "GREEN":
                    stats["green"] += 1
                elif overall == "RED":
                    stats["red"] += 1
                elif overall == "PARTIAL":
                    stats["partial"] += 1
                else:
                    stats["unknown"] += 1
            else:
                stats["unknown"] += 1
        
        return stats

# ============================================================================
# NOVO: FUNÇÃO SHOW_AUDIT_PAGE ATUALIZADA (FASE 7.1)
# ============================================================================
def show_audit_page():
    """Página de auditoria atualizada para o novo sistema estratégico"""
    st.header("📋 Sistema de Auditoria v1.6")
    
    # Inicializar sistema
    if "audit_system" not in st.session_state:
        st.session_state.audit_system = AuditSystem()
    
    audit_system = st.session_state.audit_system
    
    # NOVA: Métricas de efetividade por tese
    st.subheader("📈 Efetividade por Estratégia")
    
    # Calcular hit rate por categoria estratégica (não por tipo antigo)
    if st.button("📊 Calcular Efetividade das Estratégias"):
        strategy_stats = {}
        for entry in audit_system.audit_data:
            trixie_type = entry.get("trixie_type", "unknown")
            if "validation" in entry and entry["validation"].get("overall") == "GREEN":
                if trixie_type not in strategy_stats:
                    strategy_stats[trixie_type] = {"hits": 0, "total": 0}
                strategy_stats[trixie_type]["hits"] += 1
            # Contar total
            if trixie_type not in strategy_stats:
                strategy_stats[trixie_type] = {"hits": 0, "total": 0}
            strategy_stats[trixie_type]["total"] += 1
        
        # Exibir resultados
        if strategy_stats:
            df_strategy = pd.DataFrame([
                {
                    "Estratégia": strategy,
                    "Hit Rate": f"{(stats['hits']/stats['total']*100 if stats['total']>0 else 0):.1f}%",
                    "Hits": stats['hits'],
                    "Total": stats['total']
                }
                for strategy, stats in strategy_stats.items()
            ])
            st.dataframe(df_strategy.sort_values("Hit Rate", ascending=False), use_container_width=True)
    
    # Filtros ATUALIZADOS para o novo sistema
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        date_filter = st.date_input("Filtrar por data", value=datetime.now())
        date_str = date_filter.strftime("%Y-%m-%d") if date_filter else TODAY
    
    with col2:
        # FILTROS ATUALIZADOS: categorias estratégicas novas
        trixie_types = ["conservadora", "ousada", "banco", "explosao", "todos"]
        trixie_type_filter = st.selectbox("Tipo de Estratégia", trixie_types)
        trixie_type = None if trixie_type_filter == "todos" else trixie_type_filter
    
    with col3:
        all_teams = sorted(list(TEAM_ABBR_TO_ODDS.keys()))
        team_filter = st.selectbox("Filtrar por time", ["todos"] + all_teams)
        team = None if team_filter == "todos" else team_filter
    
    with col4:
        status_options = ["GREEN", "RED", "PARTIAL", "UNKNOWN", "todos"]
        status_filter = st.selectbox("Status", status_options)
        status = None if status_filter == "todos" else status_filter
    
    # Botões de ação
    col_a1, col_a2, col_a3 = st.columns(3)
    
    with col_a1:
        if st.button("🔄 Validar Trixies com Boxscore"):
            with st.spinner("Validando trixies com dados de jogo..."):
                validated_count = 0
                for entry in audit_system.audit_data:
                    if "validation" not in entry:
                        audit_system.validate_trixie_with_boxscore(entry)
                        validated_count += 1
                st.success(f"Validadas {validated_count} trixies!")
    
    with col_a2:
        if st.button("📊 Estatísticas"):
            stats = audit_system.get_validation_stats()
            
            st.subheader("📊 Estatísticas da Auditoria")
            
            col_s1, col_s2, col_s3, col_s4 = st.columns(4)
            
            with col_s1:
                st.metric("Total Trixies", stats["total"])
            
            with col_s2:
                st.metric("Validadas", stats["validated"])
            
            with col_s3:
                green_rate = (stats["green"] / stats["validated"] * 100) if stats["validated"] > 0 else 0
                st.metric("Green Rate", f"{green_rate:.1f}%")
            
            with col_s4:
                red_rate = (stats["red"] / stats["validated"] * 100) if stats["validated"] > 0 else 0
                st.metric("Red Rate", f"{red_rate:.1f}%")
    
    with col_a3:
        if st.button("🧹 Limpar Auditoria"):
            if st.checkbox("Confirmar limpeza completa"):
                audit_system.audit_data = []
                audit_system._save_audit_data()
                st.success("Auditoria limpa!")
                st.rerun()
    
    # Obter dados filtrados
    audit_data = audit_system.get_audit_data(date_str, trixie_type, team, status)
    
    st.subheader(f"📈 Registros de Auditoria ({len(audit_data)} encontrados)")
    
    if not audit_data:
        st.info("Nenhum registro de auditoria encontrado para os filtros selecionados.")
        return
    
    # Mostrar cada trixie auditada
    for idx, entry in enumerate(audit_data):
        trixie_type = entry.get('trixie_type', 'unknown')
        # Mapear para emoji e título apropriados
        type_emojis = {
            "conservadora": "🟢",
            "ousada": "🔥", 
            "banco": "💰",
            "explosao": "🚀"
        }
        emoji = type_emojis.get(trixie_type, "🎯")
        
        with st.expander(f"{emoji} Trixie {idx+1}: {entry.get('game', {}).get('away', '?')} @ {entry.get('game', {}).get('home', '?')} - {trixie_type.upper()} - Score: {entry.get('score', 0):.2f}"):
            col_e1, col_e2 = st.columns([2, 1])
            
            with col_e1:
                st.write(f"**Data:** {entry.get('date')}")
                st.write(f"**Hora:** {entry.get('timestamp', '')[:19]}")
                st.write(f"**Tipo:** {entry.get('trixie_type')}")
                st.write(f"**Score:** {entry.get('score', 0):.2f}")
                st.write(f"**Sistema Avançado:** {'✅ Sim' if entry.get('enhanced') else '❌ Não'}")
            
            with col_e2:
                game_info = entry.get('game', {})
                st.write(f"**Jogo:** {game_info.get('away', '?')} @ {game_info.get('home', '?')}")
                if game_info.get('spread'):
                    st.write(f"**Spread:** {game_info.get('spread')}")
                if game_info.get('total'):
                    st.write(f"**Total:** {game_info.get('total')}")
                
                # Status de validação
                if "validation" in entry:
                    validation = entry["validation"]
                    overall = validation.get("overall", "UNKNOWN")
                    if overall == "GREEN":
                        st.success(f"✅ Status: {overall}")
                    elif overall == "RED":
                        st.error(f"❌ Status: {overall}")
                    elif overall == "PARTIAL":
                        st.warning(f"⚠️ Status: {overall}")
                    else:
                        st.info(f"🔵 Status: {overall}")
                else:
                    st.info("🔵 Status: Não validado")
            
            st.markdown("---")
            st.subheader("👥 Jogadores e Legs")
            
            for i, player in enumerate(entry.get('players', [])):
                col_p1, col_p2, col_p3 = st.columns([3, 2, 1])
                
                with col_p1:
                    st.write(f"**{player.get('name')}** ({player.get('team')})")
                    st.write(f"Posição: {player.get('position')}")
                    
                    stats = player.get('stats', {})
                    stats_text = f"MIN: {stats.get('min_L5', 0):.1f} | "
                    stats_text += f"PTS: {stats.get('pts_L5', 0):.1f} | "
                    stats_text += f"REB: {stats.get('reb_L5', 0):.1f} | "
                    stats_text += f"AST: {stats.get('ast_L5', 0):.1f} | "
                    stats_text += f"PRA: {stats.get('pra_L5', 0):.1f}"
                    st.write(stats_text)
                
                with col_p2:
                    mercado = player.get('mercado', {})
                    if mercado:
                        st.metric(
                            label=f"{mercado.get('tipo')}",
                            value=f"{mercado.get('base_valor', 0):.1f}",
                            help=f"Tese: {player.get('tese_efetiva', 'N/A')}"
                        )
                    
                    tags = player.get('tags', [])[:3]
                    if tags:
                        st.caption(f"Teses: {', '.join(tags)}")
                
                with col_p3:
                    # Mostrar status da leg se validado
                    if "validation" in entry and i < len(entry["validation"]["players"]):
                        player_val = entry["validation"]["players"][i]
                        status = player_val.get("status", "UNKNOWN")
                        if status == "GREEN":
                            st.markdown('<div style="color: green; font-size: 24px;">●</div>', unsafe_allow_html=True)
                            st.caption(f"Green: {player_val.get('actual', 0):.1f} ≥ {player_val.get('target', 0):.1f}")
                        elif status == "RED":
                            st.markdown('<div style="color: red; font-size: 24px;">●</div>', unsafe_allow_html=True)
                            st.caption(f"Red: {player_val.get('actual', 0):.1f} < {player_val.get('target', 0):.1f}")
                        elif status == "NO_DATA":
                            st.markdown('<div style="color: gray; font-size: 24px;">●</div>', unsafe_allow_html=True)
                            st.caption("Sem dados")
                        else:
                            st.markdown('<div style="color: gray; font-size: 24px;">●</div>', unsafe_allow_html=True)
                            st.caption("Não validado")
                    else:
                        st.markdown('<div style="color: gray; font-size: 24px;">●</div>', unsafe_allow_html=True)
                        st.caption("Não validado")
            
            # Botão para validar esta trixie específica
            if st.button(f"🔍 Validar Esta Trixie", key=f"validate_{entry.get('id', idx)}"):
                validated_entry = audit_system.validate_trixie_with_boxscore(entry)
                st.success("Trixie validada!")
                st.rerun()
# ============================================================================
# NOVAS PÁGINAS (das novas páginas)
# ============================================================================

def show_matchup_map():
    """Página do Mapa de Matchups"""
    st.header("🗺️ Mapa de Matchups do Dia")
    
    if 'scoreboard' not in st.session_state:
        st.warning("Carregue os dados primeiro na página Dashboard")
        return
    
    games = st.session_state.scoreboard or []
    
    if not games:
        st.info("Nenhum jogo encontrado para hoje.")
        return
    
    # Grid de jogos
    st.subheader("🎯 Confrontos de Hoje")
    cols = st.columns(2)
    
    for idx, game in enumerate(games):
        with cols[idx % 2]:
            away = game.get("away", "")
            home = game.get("home", "")
            
            # Criar card do jogo
            st.markdown(f'<div class="game-card">', unsafe_allow_html=True)
            st.markdown(f"### {away} @ {home}")
            
            # DvP Analysis se disponível
            dvp_analyzer = st.session_state.get("dvp_analyzer")
            if dvp_analyzer and dvp_analyzer.defense_data:
                if away in dvp_analyzer.defense_data or home in dvp_analyzer.defense_data:
                    st.write("**📊 DvP Disponível:** Sim")
                    
                    # Análise rápida
                    st.write("**Análise Rápida:**")
                    
                    # Time visitante
                    if away in dvp_analyzer.defense_data:
                        st.write(f"**{away} Defesa:**")
                        for pos in ["PG", "SG", "SF", "PF", "C"][:3]:  # Mostrar apenas 3 posições
                            rank = dvp_analyzer.get_position_rank(away, pos, "points")
                            if rank <= 10:
                                st.write(f"  ✅ {pos}: Rank #{rank}")
                    
                    # Time da casa
                    if home in dvp_analyzer.defense_data:
                        st.write(f"**{home} Defesa:**")
                        for pos in ["PG", "SG", "SF", "PF", "C"][:3]:
                            rank = dvp_analyzer.get_position_rank(home, pos, "points")
                            if rank <= 10:
                                st.write(f"  ✅ {pos}: Rank #{rank}")
            
            st.markdown('</div>', unsafe_allow_html=True)
    
    # Melhores oportunidades por estatística
    st.subheader("🔥 Melhores Oportunidades")
    
    if 'df_l5' not in st.session_state or st.session_state.df_l5.empty:
        st.info("Carregue dados L5 para ver oportunidades")
        return
    
    df_l5 = st.session_state.df_l5
    
    # Filtrar jogadores com minutos decentes
    df_active = df_l5[df_l5['MIN_AVG'] >= 15]
    
    if df_active.empty:
        st.info("Nenhum jogador com minutos suficientes")
        return
    
    # Estatísticas para análise
    stats = ["PTS_AVG", "REB_AVG", "AST_AVG", "PRA_AVG"]
    stat_names = ["Pontos", "Rebotes", "Assistências", "PRA"]
    
    for stat, stat_name in zip(stats, stat_names):
        if stat in df_active.columns:
            top_players = df_active.nlargest(5, stat)[['PLAYER', 'TEAM', stat]]
            
            with st.expander(f"🎯 Top 5 {stat_name}"):
                for _, row in top_players.iterrows():
                    player = row['PLAYER']
                    team = row['TEAM']
                    value = row[stat]
                    
                    # Verificar se tem DvP favorável
                    dvp_insight = ""
                    dvp_analyzer = st.session_state.get("dvp_analyzer")
                    if dvp_analyzer:
                        # Tentar determinar posição do jogador (simplificado)
                        if "guard" in player.lower() or "pg" in player.lower() or "sg" in player.lower():
                            pos = "PG"
                        elif "forward" in player.lower() or "sf" in player.lower() or "pf" in player.lower():
                            pos = "SF"
                        elif "center" in player.lower() or "c" in player.lower():
                            pos = "C"
                        else:
                            pos = "SG"  # Default
                        
                        # Verificar jogos hoje para ver se tem matchup
                        for game in games:
                            if team in [game.get('away'), game.get('home')]:
                                opponent = game.get('home') if team == game.get('away') else game.get('away')
                                if opponent:
                                    rank = dvp_analyzer.get_position_rank(opponent, pos, "points")
                                    if rank <= 10:
                                        dvp_insight = f" (vs {opponent}: DvP Rank #{rank})"
                    
                    st.write(f"**{player}** ({team}): {value:.1f}{dvp_insight}")

def show_recommended_trixies():
    """Página de Trixies Recomendadas"""
    st.header("🏆 Trixies Recomendadas")
    
    # Verificar se dados estão disponíveis
    if 'df_l5' not in st.session_state or st.session_state.df_l5.empty:
        st.warning("⚠️ Carregue os dados na página Dashboard primeiro!")
        return
    
    if 'scoreboard' not in st.session_state or not st.session_state.scoreboard:
        st.warning("⚠️ Nenhum jogo encontrado para hoje!")
        return
    
    st.info("Esta funcionalidade analisa automaticamente as melhores combinações de trixies baseadas em múltiplos fatores.")
    
    # Configurações
    with st.sidebar:
        st.header("⚙️ Configurações de Recomendação")
        
        # Filtros
        st.subheader("Filtros")
        
        teams = sorted(st.session_state.df_l5['TEAM'].unique())
        selected_teams = st.multiselect(
            "Times",
            teams,
            default=teams[:3] if len(teams) > 3 else teams
        )
        
        # Parâmetros de projeção
        st.subheader("Parâmetros de Projeção")
        
        season_weight = st.slider(
            "Peso da temporada",
            min_value=0.0,
            max_value=1.0,
            value=0.7,
            help="Quanto peso dar para estatísticas da temporada inteira"
        )
        
        volatility_adjustment = st.slider(
            "Ajuste de volatilidade",
            min_value=0.5,
            max_value=2.0,
            value=1.0,
            step=0.1,
            help="Multiplicador para volatilidade (maior = mais conservador)"
        )
        
        # Botão para gerar projeções
        if st.button("🚀 Gerar Projeções", type="primary"):
            st.session_state.generate_recs = True
    
    # Container principal
    if st.session_state.get("generate_recs", False):
        st.subheader("📈 Projeções do Dia")
        
        # Simular geração de projeções
        df_l5 = st.session_state.df_l5
        
        if selected_teams:
            df_filtered = df_l5[df_l5['TEAM'].isin(selected_teams)]
        else:
            df_filtered = df_l5
        
        # Limitar para não sobrecarregar
        df_filtered = df_filtered.head(20)
        
        # Obter projection_engine do session_state
        projection_engine = st.session_state.get("projection_engine")
        if not projection_engine:
            st.warning("ProjectionEngine não está disponível. Inicialize na página Config.")
            return
        
        # Gerar projeções
        projections = []
        
        for _, row in df_filtered.iterrows():
            player_id = row.get('PLAYER_ID')
            player_name = row.get('PLAYER')
            team = row.get('TEAM')
            
            # Para demonstração, usar um oponente aleatório
            all_teams = [t for t in TEAM_ABBR_TO_ODDS.keys() if t != team]
            opponent = random.choice(all_teams) if all_teams else "GSW"
            
            # Tentar determinar posição
            position = "SG"  # Default
            
            # Obter projeção
            proj = projection_engine.get_player_projection(
                player_id=player_id,
                player_name=player_name,
                team=team,
                opponent=opponent,
                position=position,
                player_context=None,
                dvp_analyzer=st.session_state.get("dvp_analyzer")
            )
            
            if proj:
                projections.append({
                    'Jogador': player_name,
                    'Time': team,
                    'Oponente': opponent,
                    'MIN Proj': proj.get('MIN_proj', 0),
                    'PTS Proj': proj.get('PTS_proj', 0),
                    'REB Proj': proj.get('REB_proj', 0),
                    'AST Proj': proj.get('AST_proj', 0),
                    'PRA Proj': proj.get('PRA_proj', 0),
                    'Volatilidade': proj.get('volatility', 0.3)
                })
        
        if projections:
            df_proj = pd.DataFrame(projections)
            
            # Formatar números
            for col in ['MIN Proj', 'PTS Proj', 'REB Proj', 'AST Proj', 'PRA Proj']:
                if col in df_proj.columns:
                    df_proj[col] = df_proj[col].round(1)
            
            if 'Volatilidade' in df_proj.columns:
                df_proj['Volatilidade'] = df_proj['Volatilidade'].round(2)
            
            # Exibir tabela
            st.dataframe(
                df_proj,
                use_container_width=True,
                height=400
            )
            
            # Estatísticas das projeções
            st.subheader("📊 Estatísticas das Projeções")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                avg_pts = df_proj['PTS Proj'].mean() if 'PTS Proj' in df_proj.columns else 0
                st.metric("Média PTS", f"{avg_pts:.1f}")
            
            with col2:
                avg_pra = df_proj['PRA Proj'].mean() if 'PRA Proj' in df_proj.columns else 0
                st.metric("Média PRA", f"{avg_pra:.1f}")
            
            with col3:
                avg_vol = df_proj['Volatilidade'].mean() if 'Volatilidade' in df_proj.columns else 0
                st.metric("Volatilidade Média", f"{avg_vol:.2f}")
            
            # Top projeções
            st.subheader("🏆 Top Projeções")
            
            if 'PTS Proj' in df_proj.columns:
                top_pts = df_proj.nlargest(5, 'PTS Proj')
                st.write("**Top 5 Pontos:**")
                st.dataframe(top_pts[['Jogador', 'Time', 'PTS Proj']])
            
            if 'PRA Proj' in df_proj.columns:
                top_pra = df_proj.nlargest(5, 'PRA Proj')
                st.write("**Top 5 PRA:**")
                st.dataframe(top_pra[['Jogador', 'Time', 'PRA Proj']])
        else:
            st.warning("Não foi possível gerar projeções. Verifique os dados.")
    else:
        st.info("Configure os parâmetros na barra lateral e clique em 'Gerar Projeções' para começar.")

# ============================================================================
# NOVO: PÁGINA DO SISTEMA AVANÇADO ATUALIZADA (FASE 6.1)
# ============================================================================

def show_advanced_system_page():
    """Página atualizada com novas funcionalidades"""
    st.header("🧪 Sistema Avançado v1.6")
    
    # Status dos módulos
    st.subheader("📦 Módulos Ativos")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.session_state.get("advanced_features_config", {}).get("dynamic_thresholds", True):
            st.success("✅ Dynamic Thresholds")
        else:
            st.warning("⚠️ Dynamic Thresholds")
        st.caption("Thresholds baseados em contexto")
    
    with col2:
        if st.session_state.get("advanced_features_config", {}).get("contextual_scoring", True):
            st.success("✅ Contextual Scoring")
        else:
            st.warning("⚠️ Contextual Scoring")
        st.caption("Scores com fatores de jogo")
    
    with col3:
        if st.session_state.get("advanced_features_config", {}).get("boost_mode", True):
            st.success("✅ Boost Mode")
        else:
            st.warning("⚠️ Boost Mode")
        st.caption("Foco em tetos explosivos")
    
    with col4:
        if "feature_store" in st.session_state:
            st.success("✅ Feature Store")
        else:
            st.warning("⚠️ Feature Store")
        st.caption("Cache otimizado de features")
    
    # Configurações
    st.subheader("⚙️ Configurações Avançadas")
    
    use_advanced = st.checkbox(
        "🔄 Ativar Todas as Melhorias",
        value=st.session_state.get("use_advanced_features", False),
        help="Ativa thresholds dinâmicos, scoring contextual e Boost Mode"
    )
    
    if use_advanced:
        with st.expander("🔧 Configurações Detalhadas"):
            col_a, col_b, col_c, col_d = st.columns(4)
            
            with col_a:
                dynamic_thresh = st.checkbox(
                    "Thresholds Dinâmicos",
                    value=st.session_state.get("advanced_features_config", {}).get("dynamic_thresholds", True)
                )
            
            with col_b:
                contextual = st.checkbox(
                    "Scoring Contextual",
                    value=st.session_state.get("advanced_features_config", {}).get("contextual_scoring", True)
                )
            
            with col_c:
                boost_mode = st.checkbox(
                    "Boost Mode",
                    value=st.session_state.get("advanced_features_config", {}).get("boost_mode", True)
                )
            
            with col_d:
                feature_store = st.checkbox(
                    "Feature Store",
                    value="feature_store" in st.session_state,
                    disabled=True
                )
            
            # Botão para salvar
            if st.button("💾 Salvar Configurações"):
                st.session_state.advanced_features_config = {
                    "dynamic_thresholds": dynamic_thresh,
                    "contextual_scoring": contextual,
                    "boost_mode": boost_mode,
                    "pace_adjuster": st.session_state.get("advanced_features_config", {}).get("pace_adjuster", True),
                    "vacuum_matrix": st.session_state.get("advanced_features_config", {}).get("vacuum_matrix", True),
                    "correlation_filters": st.session_state.get("advanced_features_config", {}).get("correlation_filters", True)
                }
                st.success("Configurações salvas!")
    
    # Botão para ativar/desativar
    if st.button("🚀 Aplicar Configurações do Sistema"):
        st.session_state.use_advanced_features = use_advanced
        if use_advanced:
            st.success("Sistema Avançado ATIVADO!")
            st.info("As próximas trixies geradas usarão as melhorias da FASE 1.6.")
        else:
            st.success("Sistema Avançado DESATIVADO!")
            st.info("Retornando ao sistema tradicional.")
    
    st.markdown("---")
    
    # Testes rápidos
    st.subheader("🧪 Testes Rápidos")
    
    col_t1, col_t2 = st.columns(2)
    
    with col_t1:
        if st.button("🔍 Testar Thresholds Dinâmicos"):
            # Teste simples
            test_player = {"position": "C", "reb_L5": 8.5}
            test_team = {"REB": 44.2}
            
            threshold = calculate_dynamic_threshold("REB", test_player, test_team)
            st.write(f"**Teste Threshold Dinâmico (C, REB):**")
            st.write(f"- League avg: {TEAM_STATS_AVG['REB']}")
            st.write(f"- Threshold calculado: {threshold:.1f}")
            st.write(f"- Player REB: {test_player['reb_L5']}")
            st.write(f"- Resultado: {'✅ PASS' if test_player['reb_L5'] >= threshold else '❌ FAIL'}")
    
    with col_t2:
        if st.button("📊 Comparar Trixies"):
            st.info("Execute a geração de trixies com sistema ativo e inativo para comparar.")
            st.write("**Como testar:**")
            st.write("1. Desative o sistema")
            st.write("2. Gere trixies para um jogo")
            st.write("3. Ative o sistema")
            st.write("4. Gere trixies para o mesmo jogo")
            st.write("5. Compare os resultados")
    
    # Informações técnicas
    with st.expander("📋 Informações Técnicas"):
        st.write(f"**TEAM_PACE_DATA disponível:** {len(TEAM_PACE_DATA)} times")
        st.write(f"**TEAM_STATS_AVG disponível:** {len(TEAM_STATS_AVG)} estatísticas")
        st.write(f"**TRIXIE_WEIGHT_MAP:** 4 tipos de trixies configurados")
        st.write(f"**TESES disponíveis:** {len(TESE_LIST)} teses")
        
        # Stats do sistema
        if st.session_state.get("enhanced_trixies_generated", 0) > 0:
            st.write("**📊 Estatísticas de Uso:**")
            st.write(f"- Trixies geradas com sistema: {st.session_state.enhanced_trixies_generated}")
            if st.session_state.get("filtered_trixies_count", 0) > 0:
                st.write(f"- Trixies filtradas: {st.session_state.filtered_trixies_count}")
        
        # Informações dos módulos
        st.write("**Módulos disponíveis:**")
        st.write(f"  - Pace Adjuster: {'✅' if PACE_ADJUSTER_AVAILABLE else '❌'}")
        st.write(f"  - Vacuum Matrix: {'✅' if VACUUM_MATRIX_AVAILABLE else '❌'}")
        st.write(f"  - Correlation Filters: {'✅' if CORRELATION_FILTERS_AVAILABLE else '❌'}")
        st.write(f"  - Enhanced System: {'✅' if ENHANCED_SYSTEM_AVAILABLE else '❌'}")
    
    # Botão para recarregar módulos
    if st.button("🔄 Recarregar Módulos"):
        # Limpar session state dos módulos
        for key in ["pace_adjuster", "vacuum_analyzer", "correlation_validator", "enhanced_system", "feature_store"]:
            if key in st.session_state:
                del st.session_state[key]
        
        st.success("Módulos recarregados! Reinicie a página para aplicar.")

def show_feature_flags():
    """Interface para gerenciar feature flags"""
    st.header("⚙️ Feature Flags")
    
    st.info("Controle quais funcionalidades avançadas estão ativas no sistema.")
    
    # Feature flags do sistema
    feature_flags_config = {
        "ADVANCED_PROJECTIONS": "Projeções Avançadas (ProjectionEngine)",
        "INJURY_RIPPLE_EFFECT": "Efeito Cascata de Lesões",
        "USAGE_SPIKE_DETECTOR": "Detector de Picos de Uso",
        "MATCHUP_CLASSIFIER": "Classificador de Matchups",
        "SAVE_FAVORITES": "Salvar Trixies Favoritas",
        "AUDIT_SYSTEM": "Sistema de Auditoria (debug)",
        "PACE_ADJUSTER": "Pace Adjuster (FASE 1A)",
        "VACUUM_MATRIX": "Vacuum Matrix (FASE 1B)",
        "CORRELATION_FILTERS": "Correlation Filters (FASE 4)",
        "ENHANCED_SYSTEM": "Sistema Integrado (FASE 1)",
        "DYNAMIC_THRESHOLDS": "Dynamic Thresholds (FASE 2)",
        "CONTEXTUAL_SCORING": "Contextual Scoring (FASE 4)",
        "BOOST_MODE": "Boost Mode (FASE 4)"
    }
    
    flags_changed = False
    
    for flag_key, flag_desc in feature_flags_config.items():
        current_value = FEATURE_FLAGS.get(flag_key, False)
        new_value = st.checkbox(
            flag_desc,
            value=current_value,
            help=f"Ativar/desativar {flag_desc}"
        )
        
        if new_value != current_value:
            FEATURE_FLAGS[flag_key] = new_value
            flags_changed = True
    
    if flags_changed:
        st.success("✅ Feature flags atualizadas! Algumas mudanças podem requerer recarregamento.")
    
    st.markdown("---")
    
    # Configurações de performance
    st.subheader("⚡ Configurações de Performance")
    
    col1, col2 = st.columns(2)
    
    with col1:
        cache_ttl = st.selectbox(
            "TTL do Cache (minutos)",
            [5, 15, 30, 60, 120],
            index=2
        )
        st.caption(f"Cache atual: {cache_ttl} minutos")
    
    with col2:
        max_api_calls = st.slider(
            "Máx. chamadas API/min",
            min_value=10,
            max_value=100,
            value=60
        )
        st.caption(f"Limitando a {max_api_calls} chamadas por minuto")
    
    if st.button("💾 Salvar Configurações de Performance"):
        PERFORMANCE_CONFIG["cache_ttl_minutes"]["stats"] = cache_ttl
        PERFORMANCE_CONFIG["max_api_calls_per_minute"] = max_api_calls
        st.success("Configurações de performance salvas!")

def show_projections_page():
    """Página de Projeções Avançadas (versão simplificada)"""
    st.title("📊 Projeções Avançadas")
    
    # Verificar se dados estão carregados
    if 'df_l5' not in st.session_state or st.session_state.df_l5.empty:
        st.warning("⚠️ Carregue os dados na página Dashboard primeiro!")
        return
    
    # Verificar se ProjectionEngine está disponível
    projection_engine = st.session_state.get("projection_engine")
    if not projection_engine:
        st.warning("ProjectionEngine não inicializado.")
        if st.button("Inicializar ProjectionEngine"):
            st.session_state.projection_engine = ProjectionEngine()
            st.rerun()
        return
    
    st.success(f"ProjectionEngine carregado com {len(projection_engine.projections_cache)} projeções em cache.")
    
    # Sidebar para configurações
    with st.sidebar:
        st.header("⚙️ Configurações")
        
        # Filtros
        st.subheader("Filtros")
        
        teams = sorted(st.session_state.df_l5['TEAM'].unique())
        selected_teams = st.multiselect(
            "Times",
            teams,
            default=teams[:3] if len(teams) > 3 else teams
        )
        
        # Parâmetros de projeção
        st.subheader("Parâmetros de Projeção")
        
        season_weight = st.slider(
            "Peso da temporada",
            min_value=0.0,
            max_value=1.0,
            value=0.7,
            help="Quanto peso dar para estatísticas da temporada inteira"
        )
        
        volatility_adjustment = st.slider(
            "Ajuste de volatilidade",
            min_value=0.5,
            max_value=2.0,
            value=1.0,
            step=0.1,
            help="Multiplicador para volatilidade (maior = mais conservador)"
        )
        
        # Botão para gerar projeções
        if st.button("🚀 Gerar Projeções", type="primary"):
            st.session_state.generate_projections = True
    
    # Container principal
    if st.session_state.get("generate_projections", False):
        st.subheader("📈 Projeções do Dia")
        
        # Simular geração de projeções
        df_l5 = st.session_state.df_l5
        
        if selected_teams:
            df_filtered = df_l5[df_l5['TEAM'].isin(selected_teams)]
        else:
            df_filtered = df_l5
        
        # Limitar para não sobrecarregar
        df_filtered = df_filtered.head(20)
        
        # Gerar projeções
        projections = []
        
        for _, row in df_filtered.iterrows():
            player_id = row.get('PLAYER_ID')
            player_name = row.get('PLAYER')
            team = row.get('TEAM')
            
            # Para demonstração, usar um oponente aleatório
            all_teams = [t for t in TEAM_ABBR_TO_ODDS.keys() if t != team]
            opponent = random.choice(all_teams) if all_teams else "GSW"
            
            # Tentar determinar posição
            position = "SG"  # Default
            
            # Obter projeção
            proj = projection_engine.get_player_projection(
                player_id=player_id,
                player_name=player_name,
                team=team,
                opponent=opponent,
                position=position,
                player_context=None,
                dvp_analyzer=st.session_state.get("dvp_analyzer")
            )
            
            if proj:
                projections.append({
                    'Jogador': player_name,
                    'Time': team,
                    'Oponente': opponent,
                    'MIN Proj': proj.get('MIN_proj', 0),
                    'PTS Proj': proj.get('PTS_proj', 0),
                    'REB Proj': proj.get('REB_proj', 0),
                    'AST Proj': proj.get('AST_proj', 0),
                    'PRA Proj': proj.get('PRA_proj', 0),
                    'Volatilidade': proj.get('volatility', 0.3)
                })
        
        if projections:
            df_proj = pd.DataFrame(projections)
            
            # Formatar números
            for col in ['MIN Proj', 'PTS Proj', 'REB Proj', 'AST Proj', 'PRA Proj']:
                if col in df_proj.columns:
                    df_proj[col] = df_proj[col].round(1)
            
            if 'Volatilidade' in df_proj.columns:
                df_proj['Volatilidade'] = df_proj['Volatilidade'].round(2)
            
            # Exibir tabela
            st.dataframe(
                df_proj,
                use_container_width=True,
                height=400
            )
            
            # Estatísticas das projeções
            st.subheader("📊 Estatísticas das Projeções")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                avg_pts = df_proj['PTS Proj'].mean() if 'PTS Proj' in df_proj.columns else 0
                st.metric("Média PTS", f"{avg_pts:.1f}")
            
            with col2:
                avg_pra = df_proj['PRA Proj'].mean() if 'PRA Proj' in df_proj.columns else 0
                st.metric("Média PRA", f"{avg_pra:.1f}")
            
            with col3:
                avg_vol = df_proj['Volatilidade'].mean() if 'Volatilidade' in df_proj.columns else 0
                st.metric("Volatilidade Média", f"{avg_vol:.2f}")
            
            # Top projeções
            st.subheader("🏆 Top Projeções")
            
            if 'PTS Proj' in df_proj.columns:
                top_pts = df_proj.nlargest(5, 'PTS Proj')
                st.write("**Top 5 Pontos:**")
                st.dataframe(top_pts[['Jogador', 'Time', 'PTS Proj']])
            
            if 'PRA Proj' in df_proj.columns:
                top_pra = df_proj.nlargest(5, 'PRA Proj')
                st.write("**Top 5 PRA:**")
                st.dataframe(top_pra[['Jogador', 'Time', 'PRA Proj']])
        else:
            st.warning("Não foi possível gerar projeções. Verifique os dados.")
    else:
        st.info("Configure os parâmetros na barra lateral e clique em 'Gerar Projeções' para começar.")

# ============================================================================
# NOVO: FUNÇÕES DE TESTES (FASE 8.1)
# ============================================================================

def run_smoke_tests():
    """Testes básicos para validar as novas funcionalidades"""
    st.subheader("🧪 Testes de Validação")
    
    tests_passed = 0
    tests_total = 0
    
    # Teste 1: Dynamic Thresholds
    tests_total += 1
    try:
        threshold = calculate_dynamic_threshold("REB", {"position": "C"}, {"REB": 44.2})
        assert threshold > 0
        st.success("✅ Teste 1: Dynamic Thresholds funcionando")
        tests_passed += 1
    except Exception as e:
        st.error(f"❌ Teste 1 falhou: {e}")
    
    # Teste 2: Feature Store
    tests_total += 1
    try:
        feature_store = FeatureStore()
        assert feature_store is not None
        st.success("✅ Teste 2: Feature Store funcionando")
        tests_passed += 1
    except Exception as e:
        st.error(f"❌ Teste 2 falhou: {e}")
    
    # Teste 3: Teses Novas
    tests_total += 1
    try:
        test_player = {"stl_L5": 2.0, "blk_L5": 1.5, "3pm_L5": 3.0}
        test_ctx = {}
        
        # Verificar se as funções existem
        assert callable(tese_steal_explosion)
        assert callable(tese_block_explosion)
        assert callable(tese_three_point_potential)
        
        st.success("✅ Teste 3: Novas Teses funcionando")
        tests_passed += 1
    except Exception as e:
        st.error(f"❌ Teste 3 falhou: {e}")
    
    # Teste 4: Score Boost Mode
    tests_total += 1
    try:
        test_player = {
            "proj_ceil_95_pra": 40.0,
            "pra_L5": 25.0,
            "stl_L5": 1.8,
            "blk_L5": 1.2,
            "3pm_L5": 2.5,
            "is_underdog": True,
            "volatility": "high",
            "dvp_data": {"overall": 1.1}
        }
        test_ctx = {"pace_expected": 105}
        
        score = score_player_for_boost_mode(test_player, test_ctx)
        assert score > 0
        st.success("✅ Teste 4: Score Boost Mode funcionando")
        tests_passed += 1
    except Exception as e:
        st.error(f"❌ Teste 4 falhou: {e}")
    
    # Resultado
    st.markdown("---")
    st.subheader(f"📊 Resultado: {tests_passed}/{tests_total} testes passaram")
    
    if tests_passed == tests_total:
        st.success("🎉 Todas as novas funcionalidades estão operacionais!")
    else:
        st.warning("⚠️ Algumas funcionalidades precisam de atenção")

# ============================================================================
# FUNÇÕES AUXILIARES E SESSION STATE (ATUALIZADA)
# ============================================================================

def safe_load_initial_data():
    """Carrega dados iniciais no session_state - VERSÃO ATUALIZADA"""
    if "scoreboard" not in st.session_state:
        st.session_state.scoreboard = fetch_espn_scoreboard(progress_ui=False)
    
    if "team_advanced" not in st.session_state:
        st.session_state.team_advanced = fetch_team_advanced_stats()
    
    if "team_opponent" not in st.session_state:
        st.session_state.team_opponent = fetch_team_opponent_stats()
    
    if "odds" not in st.session_state:
        st.session_state.odds = fetch_odds_for_today()
    
    if "name_overrides" not in st.session_state:
        st.session_state.name_overrides = load_name_overrides()
    
    if "df_l5" not in st.session_state:
        saved = load_pickle(L5_CACHE_FILE)
        st.session_state.df_l5 = saved.get("df") if saved and isinstance(saved, dict) else pd.DataFrame()
    
    if "injuries_monitor" not in st.session_state or st.session_state.injuries_monitor is None:
        st.session_state.injuries_monitor = init_injury_monitor_flexible()
    
    if "injuries_data" not in st.session_state:
        st.session_state.injuries_data = {}
    
    if "momentum_data" not in st.session_state:
        st.session_state.momentum_data = get_momentum_data()
    
    if "dvp_analyzer" not in st.session_state:
        st.session_state.dvp_analyzer = DvPAnalyzer()
    
    # ProjectionEngine
    if "projection_engine" not in st.session_state:
        st.session_state.projection_engine = ProjectionEngine()
    
    # NOVO: Inicializar módulos avançados
    if "pace_adjuster" not in st.session_state:
        if PACE_ADJUSTER_AVAILABLE:
            st.session_state.pace_adjuster = PaceAdjuster()
        else:
            st.session_state.pace_adjuster = None
    
    if "vacuum_analyzer" not in st.session_state:
        if VACUUM_MATRIX_AVAILABLE:
            st.session_state.vacuum_analyzer = VacuumMatrixAnalyzer()
        else:
            st.session_state.vacuum_analyzer = None
    
    if "correlation_validator" not in st.session_state:
        if CORRELATION_FILTERS_AVAILABLE:
            st.session_state.correlation_validator = TrixieCorrelationValidator()
        else:
            st.session_state.correlation_validator = None
    
    if "enhanced_system" not in st.session_state:
        if ENHANCED_SYSTEM_AVAILABLE:
            st.session_state.enhanced_system = EnhancedTrixieSystem()
        else:
            st.session_state.enhanced_system = None
    
    # NOVO: Feature Store
    if "feature_store" not in st.session_state:
        st.session_state.feature_store = FeatureStore()
    
    # NOVO: Sistema de auditoria
    if "audit_system" not in st.session_state:
        st.session_state.audit_system = AuditSystem()
    
    # NOVO: Feature flags para o usuário
    if "use_advanced_features" not in st.session_state:
        st.session_state.use_advanced_features = False
    
    if "advanced_features_config" not in st.session_state:
        st.session_state.advanced_features_config = {
            "pace_adjuster": True,
            "vacuum_matrix": True,
            "correlation_filters": True,
            "dynamic_thresholds": True,
            "contextual_scoring": True,
            "boost_mode": True
        }
    
    # Feature flag para projeções avançadas
    if "use_advanced_projections" not in st.session_state:
        st.session_state.use_advanced_projections = False
    
    # Flags para novas páginas
    if "generate_recs" not in st.session_state:
        st.session_state.generate_recs = False
    
    if "generate_projections" not in st.session_state:
        st.session_state.generate_projections = False
    
    # Stats do sistema avançado
    if "enhanced_trixies_generated" not in st.session_state:
        st.session_state.enhanced_trixies_generated = 0
    
    if "filtered_trixies_count" not in st.session_state:
        st.session_state.filtered_trixies_count = 0
    
    # Carregar lesões se houver monitor
    im = st.session_state.injuries_monitor
    if im:
        try:
            if hasattr(im, "get_all_injuries"):
                st.session_state.injuries_data = im.get_all_injuries()
        except Exception:
            st.session_state.injuries_data = {}

# ============================================================================
# CUSTOM CSS
# ============================================================================

CUSTOM_CSS = """
<style>
body, .stApp {
    background-color: #050915;
    color: #F5F7FA;
    font-family: 'Inter', sans-serif;
}
h1, h2, h3, h4 {
    font-family: 'Montserrat', sans-serif;
    color: #E5F2FF;
}
.block-container {
    padding-top: 1.5rem;
}
div[data-testid="stMetricValue"] {
    color: #00E5FF;
}
.badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 11px;
    margin-right: 4px;
    margin-bottom: 2px;
    color: #F5F7FA;
}
.badge-blue { background: #1E90FF33; border: 1px solid #1E90FF; }
.badge-green { background: #00FF9C33; border: 1px solid #00FF9C; }
.badge-purple { background: #9B59B633; border: 1px solid #9B59B6; }
.badge-red { background: #FF4F4F33; border: 1px solid #FF4F4F; }
.badge-orange { background: #FFA50033; border: 1px solid #FFA500; }
.badge-grey { background: #4F4F4F66; border: 1px solid #777777; }
.trixie-card {
    border-radius: 10px;
    padding: 12px 16px;
    margin-bottom: 10px;
    background: #0B1220;
    border: 1px solid #1E293B;
}
.trixie-title {
    font-weight: 600;
    color: #00E5FF;
}
.trixie-subtitle {
    font-size: 13px;
    color: #9CA3AF;
}
.footer {
    margin-top: 24px;
    font-size: 11px;
    color: #6B7280;
    text-align: center;
}
.footer span.highlight {
    color: #00E5FF;
}
.stat-card {
    background: #0B1220;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 10px;
    border-left: 4px solid #00E5FF;
}
.stat-title {
    font-size: 14px;
    color: #9CA3AF;
    margin-bottom: 5px;
}
.stat-value {
    font-size: 18px;
    font-weight: bold;
    color: #00E5FF;
}
.game-card {
    background: #0B1220;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
    border: 1px solid #1E293B;
}
.tese-card {
    background: rgba(30, 144, 255, 0.1);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    border-left: 4px solid #1E90FF;
}
.injury-card {
    background: rgba(255, 79, 79, 0.1);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    border-left: 4px solid #FF4F4F;
}
.healthy-card {
    background: rgba(0, 255, 156, 0.1);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    border-left: 4px solid #00FF9C;
}
.blowout-card {
    background: rgba(255, 165, 0, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
    border: 2px solid #FFA500;
}
.sidebar .sidebar-content {
    background-color: #0B1220;
}
.dvp-favorable {
    background: rgba(0, 255, 156, 0.15);
    border-left: 4px solid #00FF9C;
    padding: 8px;
    border-radius: 4px;
    margin: 4px 0;
}
.dvp-unfavorable {
    background: rgba(255, 79, 79, 0.15);
    border-left: 4px solid #FF4F4F;
    padding: 8px;
    border-radius: 4px;
    margin: 4px 0;
}
.dvp-neutral {
    background: rgba(255, 255, 255, 0.05);
    border-left: 4px solid #9CA3AF;
    padding: 8px;
    border-radius: 4px;
    margin: 4px 0;
}
.enhanced-badge {
    background: rgba(0, 229, 255, 0.15);
    border: 1px solid #00E5FF;
    color: #00E5FF;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 10px;
    margin-left: 5px;
}
.status-green {
    color: #00FF9C;
    font-weight: bold;
}
.status-red {
    color: #FF4F4F;
    font-weight: bold;
}
.status-gray {
    color: #9CA3AF;
    font-weight: bold;
}
.boost-mode-badge {
    background: rgba(255, 215, 0, 0.15);
    border: 1px solid #FFD700;
    color: #FFD700;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    margin: 5px 0;
}
</style>
"""

FONT_LINKS = """
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Montserrat:wght@600;700&display=swap" rel="stylesheet">
"""

# ============================================================================
# FUNÇÃO PRINCIPAL ATUALIZADA
# ============================================================================
def main():
    st.set_page_config(page_title="NBA Analytics Suite v1.6", layout="wide")
    st.markdown(FONT_LINKS, unsafe_allow_html=True)
    st.markdown(CUSTOM_CSS, unsafe_allow_html=True)
    
    # Barra lateral com logo da NBA
    st.sidebar.image("https://cdn.nba.com/logos/nba/nba-logoman-75-word_white.svg", use_column_width=True)
    st.sidebar.markdown("## Analytics Suite v1.6")
    st.sidebar.markdown("---")
    
    # Título principal
    st.title("🏀 NBA Analytics Suite v1.6")
    st.markdown(f"**Data:** {TODAY} • **Versão:** Motor Estratégico + Múltipla do Dia + Mapa de Rotações")
    
    # Carregar dados iniciais
    safe_load_initial_data()
    
    # Inicializar motor estratégico
    initialize_strategic_engine()
    
    # Menu lateral COMPLETO com novas abas
    st.sidebar.header("📊 Menu de Navegação")
    menu_options = [
        "🏠 Dashboard",
        "🏥 Depto Médico",
        "📈 Estatísticas Jogador",
        "⚡ Momentum",
        "🛡️ DvP Analysis",
        "📊 Projeções Avançadas",
        "🗺️ Mapa de Matchups",
        "🏆 Trixies Recomendadas",
        "🎯 TRIXIE",  # Nova aba única para trixies estratégicas
        "🎲 Múltipla do Dia",  # Nova aba para múltipla do dia
        "🔄 Mapa de Rotações",  # Nova aba para análise de rotações
        "🧪 Sistema Avançado",
        "📋 Auditoria",
        "⚙️ Config",
        "🧪 Testes de Validação"
    ]
    choice = st.sidebar.radio("Selecione:", menu_options)
    
    # ============================================================================
    # DASHBOARD (ATUALIZADO)
    # ============================================================================
    if choice == "🏠 Dashboard":
        st.header("📊 Dashboard")
        
        # Métricas
        col1, col2, col3, col4, col5 = st.columns(5)
        
        with col1:
            df_l5 = st.session_state.get('df_l5', pd.DataFrame())
            st.metric("Jogadores L5", len(df_l5) if not df_l5.empty else 0)
        
        with col2:
            games = st.session_state.scoreboard or []
            st.metric("Jogos Hoje", len(games))
        
        with col3:
            odds = st.session_state.odds or {}
            st.metric("Confrontos com Odds", len(odds))
        
        with col4:
            injuries_count = 0
            if st.session_state.injuries_data:
                for team_injuries in st.session_state.injuries_data.values():
                    injuries_count += len(team_injuries)
            st.metric("Lesionados", injuries_count)
        
        with col5:
            dvp_analyzer = st.session_state.get("dvp_analyzer")
            if dvp_analyzer and dvp_analyzer.defense_data:
                st.metric("Times DvP", len(dvp_analyzer.defense_data))
            else:
                st.metric("Times DvP", 0)

        st.markdown("---")
        # NOVA SEÇÃO: Status do Sistema Estratégico
        st.subheader("🎯 Motor Estratégico")
        col_adv1, col_adv2, col_adv3, col_adv4 = st.columns(4)
        
        with col_adv1:
            status = "✅ ATIVO" if st.session_state.get("use_strategic_engine", False) else "❌ INATIVO"
            st.metric("Status Motor", status)
        with col_adv2:
            modules_active = st.session_state.get("strategic_modules_loaded", 0)
            st.metric("Módulos Ativos", f"{modules_active}/8")
        with col_adv3:
            rotation_available = "rotation_analyzer" in st.session_state
            st.metric("Análise Rotações", "✅" if rotation_available else "❌")
        with col_adv4:
            if st.button("⚙️ Configurar Motor"):
                success = initialize_strategic_engine()
                if success:
                    st.success("✅ Motor estratégico configurado com sucesso!")
                else:
                    st.error("❌ Falha ao configurar motor estratégico")
                st.rerun()
       
        st.markdown("---")
        
        # NOVA SEÇÃO: Auditoria
        st.subheader("📋 Sistema de Auditoria")
        
        audit_system = st.session_state.get("audit_system")
        if audit_system:
            stats = audit_system.get_validation_stats()
            
            col_aud1, col_aud2, col_aud3, col_aud4 = st.columns(4)
            
            with col_aud1:
                st.metric("Trixies Auditadas", stats["total"])
            
            with col_aud2:
                st.metric("Validadas", stats["validated"])
            
            with col_aud3:
                green_rate = (stats["green"] / stats["validated"] * 100) if stats["validated"] > 0 else 0
                st.metric("Taxa Green", f"{green_rate:.1f}%")
            
            with col_aud4:
                if st.button("📊 Ver Auditoria"):
                    st.session_state.menu_choice = "📋 Auditoria"
                    st.rerun()
        
        st.markdown("---")
        
        # Jogos do dia
        st.subheader("🎯 Confrontos de Hoje")
        games = st.session_state.scoreboard or []
        odds = st.session_state.odds or {}
        
        if games:
            for i, game in enumerate(games):
                away = game.get("away")
                home = game.get("home")
                status = game.get("status", "Não iniciado")
                
                away_full = TEAM_ABBR_TO_ODDS.get(away, away)
                home_full = TEAM_ABBR_TO_ODDS.get(home, home)
                
                spread = None
                total = None
                if away_full and home_full:
                    key_full = f"{away_full}@{home_full}"
                    game_odds = odds.get(key_full, {})
                    spread = game_odds.get("spread")
                    total = game_odds.get("total")
                
                blowout_risk = False
                if spread:
                    try:
                        if abs(float(spread)) >= 10:
                            blowout_risk = True
                    except:
                        pass
                
                if blowout_risk:
                    st.markdown(f'<div class="blowout-card">', unsafe_allow_html=True)
                    st.markdown(f"### ⚠️ {away} @ {home} (RISCO DE BLOWOUT)")
                else:
                    st.markdown(f'<div class="game-card">', unsafe_allow_html=True)
                    st.markdown(f"### {away} @ {home}")
                
                st.write(f"**Status:** {status}")
                
                if spread or total:
                    odds_text = []
                    if spread:
                        odds_text.append(f"Spread: {spread}")
                    if total:
                        odds_text.append(f"Total: {total}")
                    st.write(f"**Odds:** {', '.join(odds_text)}")
                
                # Informações de Pace (NOVO)
                if st.session_state.get("use_advanced_features", False):
                    home_pace = TEAM_PACE_DATA.get(home, 100.0)
                    away_pace = TEAM_PACE_DATA.get(away, 100.0)
                    game_pace = (home_pace + away_pace) / 2.0
                    
                    pace_category = "NEUTRO"
                    if game_pace >= 102:
                        pace_category = "ALTO 🚀"
                    elif game_pace <= 98:
                        pace_category = "BAIXO 🐌"
                    
                    st.write(f"**🏃‍♂️ Ritmo do Jogo:** {game_pace:.1f} ({pace_category})")
                
                dvp_analyzer = st.session_state.get("dvp_analyzer")
                if dvp_analyzer and dvp_analyzer.defense_data:
                    if away in dvp_analyzer.defense_data or home in dvp_analyzer.defense_data:
                        st.write("**📊 DvP Disponível:** Sim")
                
                st.markdown('</div>', unsafe_allow_html=True)
        else:
            st.info("Nenhum jogo encontrado para hoje.")

    # ============================================================================
    # TRIXIE - NOVA ABA ÚNICA COM 4 SUBABAS
    # ============================================================================
    elif choice == "🎯 TRIXIE":
        display_strategic_trixies()
    
    # ============================================================================
    # MÚLTIPLA DO DIA - NOVA ABA
    # ============================================================================
    elif choice == "🎲 Múltipla do Dia":
        show_multipla_do_dia()
    
    # ============================================================================
    # MAPA DE ROTAÇÕES - NOVA ABA
    # ============================================================================

    elif choice == "🔄 Mapa de Rotações":
        show_mapa_rotacoes()

       # Estatísticas Rápidas
        st.subheader("📈 Estatísticas Rápidas")
        if not df_cached.empty:
            col_s1, col_s2, col_s3 = st.columns(3)
            
            with col_s1:
                top_scorers = df_cached.nlargest(5, 'PTS_AVG')[['PLAYER', 'PTS_AVG']]
                st.write("**Top Scorers (L5):**")
                st.dataframe(top_scorers.style.format({'PTS_AVG': '{:.1f}'}), use_container_width=True)
            
            with col_s2:
                top_rebounders = df_cached.nlargest(5, 'REB_AVG')[['PLAYER', 'REB_AVG']]
                st.write("**Top Rebounders (L5):**")
                st.dataframe(top_rebounders.style.format({'REB_AVG': '{:.1f}'}), use_container_width=True)
            
            with col_s3:
                top_assisters = df_cached.nlargest(5, 'AST_AVG')[['PLAYER', 'AST_AVG']]
                st.write("**Top Assisters (L5):**")
                st.dataframe(top_assisters.style.format({'AST_AVG': '{:.1f}'}), use_container_width=True)
        
        st.markdown(
            '<div class="footer">NBA Analytics Suite v1.6 • Criado por <span class="highlight">Egner</span> • Assistência IA <span class="highlight">DeepSeek</span></div>',
            unsafe_allow_html=True
        )

        # Dashboard rápido
        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("🏠 Ir para Dashboard"):
                st.session_state.menu_choice = "🏠 Dashboard"
                st.rerun()
        with col2:
            if st.button("🎯 Ir para TRIXIE"):
                st.session_state.menu_choice = "🎯 TRIXIE"
                st.rerun()
        with col3:
            if st.button("🎲 Ver Múltipla do Dia"):
                st.session_state.menu_choice = "🎲 Múltipla do Dia"
                st.rerun()

    # ============================================================================
    # ESCALAÇÕES ENRIQUECIDAS (NOVA VERSÃO)
    # ============================================================================
    elif choice == "👥 Escalações":
        st.header("👥 Escalações Enriquecidas")
        
        # VALIDAÇÃO
        critical_ok, checks = validate_pipeline_integrity(['scoreboard'])
        if not critical_ok:
            st.error("❌ Dados de scoreboard não disponíveis. Atualize na aba Config.")
        else:
            games = st.session_state.scoreboard or []
            if not games:
                st.info("Nenhum jogo encontrado.")
            else:
                indices = ["Todos"] + [f"{i}: {g.get('away')} @ {g.get('home')}" for i,g in enumerate(games)]
                sel = st.selectbox("Selecione jogo (ou 'Todos')", indices, index=0)
                
                # Painel lateral com análise de rotações
                with st.sidebar:
                    st.subheader("🔄 Análise de Rotações")
                    st.info("Formações prováveis com base em minutos juntos e contexto")
                    if "rotation_analyzer" in st.session_state:
                        rotation_analyzer = st.session_state.rotation_analyzer
                        st.success("✅ RotationAnalyzer carregado")
                    else:
                        st.warning("❌ RotationAnalyzer não inicializado")
                
                for idx,g in enumerate(games):
                    if sel!="Todos":
                        chosen = int(sel.split(":")[0])
                        if idx!=chosen: continue
                    
                    away = g.get("away")
                    home = g.get("home")
                    st.subheader(f"{away} @ {home}")
                    
                    # Buscar rosters
                    try:
                        roster_away = fetch_team_roster(away, progress_ui=False)
                        roster_home = fetch_team_roster(home, progress_ui=False)
                        list_away = extract_list(roster_away)
                        list_home = extract_list(roster_home)
                        
                        if not list_away and not list_home:
                            st.warning(f"Não foi possível obter as escalações para este jogo.")
                            continue
                        
                        # Processar jogadores com contexto enriquecido
                        def process_roster(roster_list, team_abbr, is_home):
                            processed = []
                            for entry in roster_list:
                                # Normalizar entrada
                                player = normalize_roster_entry(entry)
                                
                                # 1. Overrides de posição manual
                                position_overrides = {
                                    "LeBron James": "SF",
                                    "Nikola Jokić": "C", 
                                    "Luka Dončić": "PG",
                                    "Giannis Antetokounmpo": "PF",
                                    "Jimmy Butler": "SF",
                                    "Stephen Curry": "PG",
                                    "Joel Embiid": "C",
                                    "Jayson Tatum": "SF",
                                    "Kevin Durant": "SF",
                                    "Anthony Davis": "PF"
                                }
                                pos = position_overrides.get(player.get("PLAYER", ""), player.get("POSITION", "").upper())
                                
                                # 2. Derivar role
                                starter = player.get("STARTER", False)
                                expected_minutes = 0
                                role = "deep_bench"
                                if starter:
                                    role = "starter"
                                elif "rotation" in player.get("STATUS", "").lower():
                                    role = "rotation"
                                elif "bench" in player.get("STATUS", "").lower():
                                    role = "bench"
                                
                                # 3. Badge médico
                                status = player.get("STATUS", "").lower()
                                badge_color = "#9CA3AF"  # Cinza (desconhecido)
                                if any(k in status for k in ["out", "ir", "injur"]):
                                    badge_color = "#EF4444"  # Vermelho (fora)
                                elif "questionable" in status:
                                    badge_color = "#F59E0B"  # Laranja (questionável)
                                elif any(k in status for k in ["active", "available", "probable"]):
                                    badge_color = "#10B981"  # Verde (ativo)
                                
                                # 4. Buscar dados L5 para minutos e USG%
                                df_l5 = st.session_state.get("df_l5")
                                min_avg = 0
                                usg_pct = 0
                                pra_avg = 0
                                player_class = []
                                archetypes = []
                                
                                if df_l5 is not None and not df_l5.empty:
                                    # Buscar jogador por nome
                                    player_row = df_l5[df_l5["PLAYER"].str.contains(player.get("PLAYER", ""), case=False, na=False)]
                                    if not player_row.empty:
                                        row = player_row.iloc[0]
                                        min_avg = row.get("MIN_AVG", 0)
                                        usg_pct = row.get("USG_PCT", 0) if "USG_PCT" in df_l5.columns else 0
                                        pra_avg = row.get("PRA_AVG", 0)
                                        
                                        # Atualizar role baseado em minutos
                                        if min_avg >= 28:
                                            role = "starter"
                                        elif min_avg >= 20:
                                            role = "rotation"
                                        elif min_avg >= 12:
                                            role = "bench"
                                        
                                        # 5. Classificação estratégica
                                        if "player_classifier" in st.session_state:
                                            player_ctx = {
                                                "name": player.get("PLAYER", ""),
                                                "position": pos,
                                                "min_L5": min_avg,
                                                "reb_per_min": row.get("REB_AVG", 0)/max(min_avg, 1),
                                                "ast_per_min": row.get("AST_AVG", 0)/max(min_avg, 1),
                                                "is_starter": starter
                                            }
                                            player_class = st.session_state.player_classifier.classify_player(player_ctx)
                                        
                                        # 6. Archetypes se disponível
                                        if "archetype_engine" in st.session_state:
                                            archetypes = st.session_state.archetype_engine.get_archetypes(
                                                player_id=row.get("PLAYER_ID", ""),
                                                player_stats={
                                                    "REB_AVG": row.get("REB_AVG", 0),
                                                    "AST_AVG": row.get("AST_AVG", 0),
                                                    "PTS_AVG": row.get("PTS_AVG", 0),
                                                    "USAGE_RATE": usg_pct,
                                                    "OREB_PCT": row.get("OREB_PCT", 0) if "OREB_PCT" in df_l5.columns else 0
                                                }
                                            )
                                
                                processed.append({
                                    "PLAYER": player.get("PLAYER", "N/A"),
                                    "POSITION": pos,
                                    "ROLE": role,
                                    "MIN_AVG": min_avg,
                                    "USG_PCT": usg_pct,
                                    "STATUS": player.get("STATUS", "N/A"),
                                    "STATUS_BADGE": badge_color,
                                    "PRA_AVG": pra_avg,
                                    "PLAYER_CLASS": player_class,
                                    "ARCHETYPES": archetypes
                                })
                            
                            return processed
                        
                        # Processar ambos os times
                        away_players = process_roster(list_away, away, False)
                        home_players = process_roster(list_home, home, True)
                        
                        # Exibir em colunas lado a lado
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.markdown(f"### 🏠 {home}")
                            st.markdown("**Titulares**")
                            home_starters = [p for p in home_players if p["ROLE"] == "starter"]
                            if home_starters:
                                st.dataframe(
                                    pd.DataFrame(home_starters)[["PLAYER", "POSITION", "ROLE", "MIN_AVG", "USG_PCT", "PRA_AVG"]],
                                    use_container_width=True
                                )
                            
                            st.markdown("**Rotação**")
                            home_rotation = [p for p in home_players if p["ROLE"] in ["rotation", "bench"]]
                            if home_rotation:
                                st.dataframe(
                                    pd.DataFrame(home_rotation)[["PLAYER", "POSITION", "ROLE", "MIN_AVG", "USG_PCT", "PRA_AVG"]],
                                    use_container_width=True
                                )
                        
                        with col2:
                            st.markdown(f"### ✈️ {away}")
                            st.markdown("**Titulares**")
                            away_starters = [p for p in away_players if p["ROLE"] == "starter"]
                            if away_starters:
                                st.dataframe(
                                    pd.DataFrame(away_starters)[["PLAYER", "POSITION", "ROLE", "MIN_AVG", "USG_PCT", "PRA_AVG"]],
                                    use_container_width=True
                                )
                            
                            st.markdown("**Rotação**")
                            away_rotation = [p for p in away_players if p["ROLE"] in ["rotation", "bench"]]
                            if away_rotation:
                                st.dataframe(
                                    pd.DataFrame(away_rotation)[["PLAYER", "POSITION", "ROLE", "MIN_AVG", "USG_PCT", "PRA_AVG"]],
                                    use_container_width=True
                                )
                        
                        # Exibir status médico detalhado
                        st.markdown("---")
                        st.subheader("🏥 Status Médico Detalhado")
                        
                        col_status1, col_status2 = st.columns(2)
                        
                        with col_status1:
                            st.markdown(f"**{home}**")
                            for player in home_players:
                                badge_html = f'<span style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: {player["STATUS_BADGE"]}; margin-right: 5px;"></span>'
                                classes = ", ".join(player["PLAYER_CLASS"]) if player["PLAYER_CLASS"] else "N/A"
                                archetypes = ", ".join(player["ARCHETYPES"]) if player["ARCHETYPES"] else "N/A"
                                st.markdown(f"{badge_html} **{player['PLAYER']}** ({player['POSITION']}) - {player['STATUS']}", unsafe_allow_html=True)
                                st.caption(f"Classes: {classes} | Archetypes: {archetypes}")
                        
                        with col_status2:
                            st.markdown(f"**{away}**")
                            for player in away_players:
                                badge_html = f'<span style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: {player["STATUS_BADGE"]}; margin-right: 5px;"></span>'
                                classes = ", ".join(player["PLAYER_CLASS"]) if player["PLAYER_CLASS"] else "N/A"
                                archetypes = ", ".join(player["ARCHETYPES"]) if player["ARCHETYPES"] else "N/A"
                                st.markdown(f"{badge_html} **{player['PLAYER']}** ({player['POSITION']}) - {player['STATUS']}", unsafe_allow_html=True)
                                st.caption(f"Classes: {classes} | Archetypes: {archetypes}")
                        
                        # Painel de insights de rotação
                        if "rotation_analyzer" in st.session_state:
                            st.markdown("---")
                            st.subheader("🔄 Insights de Rotação")
                            
                            rotation_analyzer = st.session_state.rotation_analyzer
                            matchup_context = {
                                "away_team": away,
                                "home_team": home,
                                "cache_key": f"{g.get('gameId', 'unknown')}_{away}_{home}"
                            }
                            
                            insights = rotation_analyzer.get_lineup_insights(home, matchup_context)
                            st.markdown(f"**{home} Insights:**\n{insights}")
                            
                            insights = rotation_analyzer.get_lineup_insights(away, matchup_context)
                            st.markdown(f"**{away} Insights:**\n{insights}")
                    
                    except Exception as e:
                        st.error(f"Erro ao processar escalações: {e}")
                        st.exception(e)    
    # ============================================================================
    # DEPTO MÉDICO
    # ============================================================================
    elif choice == "🏥 Depto Médico":
        st.header("🏥 Depto Médico - Monitor de Lesões")
        im = st.session_state.injuries_monitor
        if im is None:
            st.warning("InjuryMonitor não inicializado. Clique para tentar.")
            if st.button("Inicializar InjuryMonitor"):
                st.session_state.injuries_monitor = init_injury_monitor_flexible()
                im = st.session_state.injuries_monitor
        if im is None:
            st.error("Módulo 'injuries.py' não disponível ou falha na inicialização.")
        else:
            st.success("InjuryMonitor disponível.")
            col1,col2 = st.columns([1,1])
            with col1:
                if st.button("Atualizar lesões (todos os times)"):
                    try:
                        games = st.session_state.scoreboard or []
                        injuries_map = {}
                        for game in games:
                            for team in [game.get('away'), game.get('home')]:
                                if team and team not in injuries_map:
                                    injuries_map[team] = im.fetch_injuries_for_team(team)
                                    time.sleep(0.2)
                        st.session_state.injuries_data = injuries_map
                        st.success("Lesões atualizadas.")
                    except Exception as e:
                        st.error(f"Erro ao atualizar lesões: {e}")
            with col2:
                if st.button("Carregar cache de lesões"):
                    try:
                        st.session_state.injuries_data = im.get_all_injuries() if hasattr(im, "get_all_injuries") else {}
                        st.success("Cache carregado.")
                    except Exception as e:
                        st.error(f"Erro ao carregar cache: {e}")
            st.markdown("---")
            injuries_map = st.session_state.injuries_data or {}
            if not injuries_map:
                st.info("Nenhuma lesão no cache. Atualize para buscar dados.")
            else:
                for team_abbr, items in injuries_map.items():
                    if not items:
                        continue
                    df = pd.DataFrame(items)
                    if 'name' in df.columns:
                        df = df.drop_duplicates(subset='name', keep='first')
                    cols_to_show = []
                    rename_dict = {}
                    if 'name' in df.columns:
                        cols_to_show.append('name')
                        rename_dict['name'] = 'Nome'
                    if 'status' in df.columns:
                        cols_to_show.append('status')
                        rename_dict['status'] = 'Status'
                    if 'date' in df.columns:
                        cols_to_show.append('date')
                        rename_dict['date'] = 'Data'
                    if cols_to_show:
                        df_display = df[cols_to_show].rename(columns=rename_dict)
                        st.markdown(f"**{team_abbr}** — {len(df_display)} registros")
                        st.dataframe(df_display, use_container_width=True)
                    else:
                        st.write("Sem dados estruturados para este time.")
            st.markdown("Jogadores 'Out' ou 'Questionable' são excluídos automaticamente das Trixies.")
    
    # ============================================================================
    # ESTATÍSTICAS JOGADOR
    # ============================================================================
    elif choice == "📈 Estatísticas Jogador":
        st.header("📈 Estatísticas Jogador")
        df_l5 = st.session_state.df_l5
        if df_l5 is None or (hasattr(df_l5,"empty") and df_l5.empty):
            if st.button("Coletar L5 agora (pode demorar)"):
                df_l5 = get_players_l5(progress_ui=True)
                st.session_state.df_l5 = df_l5
        if df_l5 is None or (hasattr(df_l5,"empty") and df_l5.empty):
            st.info("Cache L5 vazio. Colete L5 para ver estatísticas.")
        else:
            teams = sorted(df_l5["TEAM"].dropna().unique().tolist()); teams.insert(0, "Todos")
            sel_team = st.selectbox("Filtrar por time", teams, index=0)
            st.subheader("🔍 Filtros de Estatísticas")
            col_f1, col_f2, col_f3, col_f4 = st.columns(4)
            with col_f1:
                min_min = st.slider("Minutos mínimos (MIN_AVG)", 0, 40, 0)
            with col_f2:
                min_pts = st.slider("Pontos mínimos (PTS_AVG)", 0.0, 40.0, 0.0, step=0.5)
            with col_f3:
                min_reb = st.slider("Rebotes mínimos (REB_AVG)", 0.0, 20.0, 0.0, step=0.5)
            with col_f4:
                min_ast = st.slider("Assistências mínimas (AST_AVG)", 0.0, 15.0, 0.0, step=0.5)
            q = st.text_input("Procurar nome (opcional)")
            df_view = df_l5.copy()
            if sel_team!="Todos": df_view = df_view[df_view["TEAM"]==sel_team]
            if min_min>0: df_view = df_view[df_view["MIN_AVG"]>=min_min]
            if min_pts>0: df_view = df_view[df_view["PTS_AVG"]>=min_pts]
            if min_reb>0: df_view = df_view[df_view["REB_AVG"]>=min_reb]
            if min_ast>0: df_view = df_view[df_view["AST_AVG"]>=min_ast]
            if q: df_view = df_view[df_view["PLAYER"].str.contains(q, case=False, na=False)]
            for c in ["MIN_AVG","PTS_AVG","REB_AVG","AST_AVG","PRA_AVG"]:
                if c in df_view.columns: df_view[c] = df_view[c].round(2)
            st.subheader(f"📊 Resultados ({len(df_view)} jogadores)")
            st.dataframe(df_view.sort_values("PRA_AVG", ascending=False).reset_index(drop=True), use_container_width=True)
    
    # ============================================================================
    # MOMENTUM
    # ============================================================================
    elif choice == "⚡ Momentum":
        st.header("⚡ Momentum - Tendência dos Jogadores")
        momentum_data = st.session_state.momentum_data or {}
        if not momentum_data:
            st.info("Dados de momentum não disponíveis. Atualize na seção 'Config'.")
        else:
            teams = sorted(set([data.get("team") for data in momentum_data.values() if data.get("team")]))
            selected_team = st.selectbox("Filtrar por time:", ["TODOS"] + teams)
            filtered_data = {}
            for player_name, data in momentum_data.items():
                if selected_team == "TODOS" or data.get("team") == selected_team:
                    filtered_data[player_name] = data
            if not filtered_data:
                st.info("Nenhum dado de momentum disponível para o filtro selecionado.")
            else:
                sorted_players = sorted(filtered_data.items(), key=lambda x: x[1]["score"], reverse=True)
                st.subheader(f"🏆 Top 20 Momentum ({selected_team})")
                for i, (player_name, data) in enumerate(sorted_players[:20]):
                    score = data["score"]
                    team = data.get("team", "N/A")
                    min_avg = data.get("min_avg", 0)
                    pra_avg = data.get("pra_avg", 0)
                    if score >= 80:
                        color = "🟢"
                    elif score >= 60:
                        color = "🟡"
                    else:
                        color = "🔴"
                    col1, col2, col3, col4 = st.columns([3, 2, 2, 2])
                    with col1:
                        st.write(f"{color} **{player_name}** ({team})")
                    with col2:
                        st.write(f"**Score:** {score}")
                    with col3:
                        st.write(f"**MIN:** {min_avg:.1f}")
                    with col4:
                        st.write(f"**PRA:** {pra_avg:.1f}")
                    if i < 19:
                        st.markdown("---")
                st.subheader("📈 Análise de Momentum")
                if sorted_players:
                    avg_score = sum(data["score"] for _, data in sorted_players[:20]) / min(20, len(sorted_players))
                    max_score = sorted_players[0][1]["score"]
                    min_score = sorted_players[-1][1]["score"] if len(sorted_players) >= 20 else sorted_players[-1][1]["score"]
                    col_a1, col_a2, col_a3 = st.columns(3)
                    col_a1.metric("Média Top 20", f"{avg_score:.1f}")
                    col_a2.metric("Máximo", f"{max_score:.1f}")
                    col_a3.metric("Mínimo", f"{min_score:.1f}")
    
    # ============================================================================
    # DvP ANALYSIS
    # ============================================================================
    elif choice == "🛡️ DvP Analysis":
        st.header("🛡️ Defense vs Position (DvP) Analysis")
        dvp_analyzer = st.session_state.get("dvp_analyzer")
        if not dvp_analyzer or not dvp_analyzer.defense_data:
            st.warning("DvP Analyzer não inicializado. Atualize na seção Config.")
            if st.button("Inicializar DvP Analyzer"):
                st.session_state.dvp_analyzer = DvPAnalyzer()
                dvp_analyzer = st.session_state.dvp_analyzer
                st.rerun()
        else:
            st.success(f"DvP Analyzer carregado com dados de {len(dvp_analyzer.defense_data)} times.")
            teams = sorted(list(dvp_analyzer.defense_data.keys()))
            selected_team = st.selectbox("Selecione um time:", teams)
            if selected_team:
                st.subheader(f"Análise DvP - {selected_team}")
                positions = ["PG", "SG", "SF", "PF", "C"]
                data = []
                for pos in positions:
                    points_rank = dvp_analyzer.get_position_rank(selected_team, pos, "points")
                    rebounds_rank = dvp_analyzer.get_position_rank(selected_team, pos, "rebounds")
                    assists_rank = dvp_analyzer.get_position_rank(selected_team, pos, "assists")
                    data.append({
                        "Posição": pos,
                        "Pontos": points_rank,
                        "Rebotes": rebounds_rank,
                        "Assistências": assists_rank
                    })
                df_ranks = pd.DataFrame(data)
                st.dataframe(df_ranks, use_container_width=True)
                st.subheader("Análise Detalhada por Posição")
                for pos in positions:
                    analysis = dvp_analyzer.get_matchup_analysis(selected_team, pos)
                    overall = analysis.get("overall", 1.0)
                    if overall > 1.05:
                        css_class = "dvp-favorable"
                        title = f"✅ {pos} - Matchup Favorável"
                    elif overall < 0.95:
                        css_class = "dvp-unfavorable"
                        title = f"⚠️ {pos} - Matchup Desfavorável"
                    else:
                        css_class = "dvp-neutral"
                        title = f"⚪ {pos} - Matchup Neutro"
                    st.markdown(f'<div class="{css_class}">', unsafe_allow_html=True)
                    st.markdown(f"**{title}** (Multiplicador: {overall:.3f})")
                    rankings = analysis.get("rankings", {})
                    for metric, rank_info in rankings.items():
                        rank = rank_info.get("rank", 15)
                        tier = rank_info.get("tier", "Neutro")
                        st.write(f"{metric.capitalize()}: Rank #{rank} ({tier})")
                    st.markdown('</div>', unsafe_allow_html=True)
            st.markdown("---")
            st.subheader("Ações")
            col_d1, col_d2 = st.columns(2)
            with col_d1:
                if st.button("🔄 Atualizar Dados DvP"):
                    with st.spinner("Atualizando dados DvP..."):
                        st.session_state.dvp_analyzer = DvPAnalyzer()
                        st.success("Dados DvP atualizados!")
                        st.rerun()
            with col_d2:
                if st.button("🧹 Limpar Cache DvP"):
                    if os.path.exists(DVP_CACHE_FILE):
                        os.remove(DVP_CACHE_FILE)
                        st.success("Cache DvP limpo!")
                        st.session_state.dvp_analyzer = DvPAnalyzer()
                        st.rerun()
    
    # ============================================================================
    # PROJEÇÕES AVANÇADAS
    # ============================================================================
    elif choice == "📊 Projeções Avançadas":
        show_projections_page()
    
    # ============================================================================
    # MAPA DE MATCHUPS (NOVA)
    # ============================================================================
    elif choice == "🗺️ Mapa de Matchups":
        show_matchup_map()
    
    # ============================================================================
    # TRIXIES RECOMENDADAS (NOVA)
    # ============================================================================
    elif choice == "🏆 Trixies Recomendadas":
        show_recommended_trixies()
    
    # ============================================================================
    # SISTEMA AVANÇADO (NOVA PÁGINA)
    # ============================================================================
    elif choice == "🧪 Sistema Avançado":
        show_advanced_system_page()
    
    # ============================================================================
    # AUDITORIA (NOVA PÁGINA)
    # ============================================================================
    elif choice == "📋 Auditoria":
        show_audit_page()
    
    # ============================================================================
    # CONFIG
    # ============================================================================
    elif choice == "⚙️ Config":
        st.header("⚙️ Configurações v1.6")
        # Seção de Feature Flags
        st.subheader("🎛️ Feature Flags")
        show_feature_flags()
        # NOVO: Seção de Thresholds Dinâmicos
        st.subheader("📊 Configurações de Thresholds Dinâmicos")
        col_t1, col_t2, col_t3 = st.columns(3)
        with col_t1:
            pts_threshold = st.slider("Threshold PTS", min_value=10.0, max_value=30.0, value=15.0, step=0.5,
                                     help="Pontos mínimos para considerar jogador como scorer")
        with col_t2:
            reb_threshold = st.slider("Threshold REB", min_value=4.0, max_value=12.0, value=6.0, step=0.5,
                                     help="Rebotes mínimos para considerar jogador como rebounder")
        with col_t3:
            ast_threshold = st.slider("Threshold AST", min_value=3.0, max_value=10.0, value=4.0, step=0.5,
                                     help="Assistências mínimas para considerar jogador como playmaker")
        # Salvar thresholds
        if st.button("💾 Salvar Thresholds"):
            st.session_state.dynamic_thresholds = {
                "PTS": pts_threshold,
                "REB": reb_threshold,
                "AST": ast_threshold
            }
            st.success("Thresholds salvos!")
        col_c1, col_c2 = st.columns(2)
        with col_c1:
            st.subheader("🔄 Atualizar Dados")
            if st.button("🔁 Atualizar L5 Completo", type="primary"):
                with st.spinner("Atualizando dados L5..."):
                    df_l5 = get_players_l5(progress_ui=True)
                    st.session_state.df_l5 = df_l5
                    st.success(f"✅ L5 atualizado com {len(df_l5)} jogadores!")
            if st.button("🛡️ Atualizar Dados DvP"):
                with st.spinner("Atualizando dados DvP..."):
                    st.session_state.dvp_analyzer = DvPAnalyzer()
                    st.success("✅ Dados DvP atualizados!")
            if st.button("📊 Atualizar Projeções"):
                with st.spinner("Atualizando projeções..."):
                    if "projection_engine" in st.session_state:
                        # Forçar recálculo limpando cache
                        projection_engine = st.session_state.projection_engine
                        projection_engine.projections_cache = {}
                        projection_engine._save_projections_cache({})
                    st.success("✅ Projeções atualizadas!")
            if st.button("🎯 Atualizar Odds"):
                with st.spinner("Buscando odds..."):
                    st.session_state.odds = fetch_odds_for_today()
                    st.success("✅ Odds atualizadas!")
            # NOVO: Botão para testar funcionalidades
            if st.button("🧪 Testar Novas Funcionalidades"):
                run_smoke_tests()
            # NOVO: Botão para inicializar Feature Store
            if st.button("📦 Inicializar Feature Store"):
                if "feature_store" not in st.session_state:
                    st.session_state.feature_store = FeatureStore()
                    st.success("✅ Feature Store inicializado!")
                else:
                    st.info("Feature Store já inicializado")
            # NOVO: Botão para calcular efetividade das teses
            if st.button("📈 Calcular Efetividade das Teses"):
                if "audit_system" in st.session_state:
                    calculate_tese_effectiveness(st.session_state.audit_system)
                else:
                    st.warning("Sistema de auditoria não inicializado")
        with col_c2:
            st.subheader("📊 Estatísticas do Sistema")
            saved_l5 = load_pickle(L5_CACHE_FILE)
            df_cached = saved_l5.get("df") if saved_l5 and isinstance(saved_l5, dict) else pd.DataFrame()
            st.metric("Jogadores no Cache", len(df_cached))
            st.metric("Jogos Hoje", len(st.session_state.scoreboard or []))
            st.metric("Odds Carregadas", len(st.session_state.odds or {}))
            dvp_analyzer = st.session_state.get("dvp_analyzer")
            dvp_count = len(dvp_analyzer.defense_data) if dvp_analyzer else 0
            st.metric("Times DvP", dvp_count)
            projection_engine = st.session_state.get("projection_engine")
            proj_count = len(projection_engine.projections_cache) if projection_engine else 0
            st.metric("Projeções Cache", proj_count)
            momentum_count = len(st.session_state.momentum_data or {})
            st.metric("Jogadores com Momentum", momentum_count)
            # Estatísticas do Sistema Avançado
            enhanced_count = st.session_state.get("enhanced_trixies_generated", 0)
            filtered_count = st.session_state.get("filtered_trixies_count", 0)
            st.metric("Trixies Avançadas", enhanced_count)
            if filtered_count > 0:
                st.metric("Trixies Filtradas", filtered_count)
            # NOVO: Estatísticas do Feature Store
            if "feature_store" in st.session_state:
                feature_store = st.session_state.feature_store
                st.metric("Features em Cache", len(feature_store.data))
            # Estatísticas da Auditoria
            audit_system = st.session_state.get("audit_system")
            if audit_system:
                stats = audit_system.get_validation_stats()
                st.metric("Trixies Auditadas", stats["total"])
                if stats["validated"] > 0:
                    green_rate = (stats["green"] / stats["validated"] * 100)
                    st.metric("Taxa Green", f"{green_rate:.1f}%")
            # NOVO: Estatísticas do Boost Mode
            if "boost_trixies_generated" in st.session_state:
                boost_count = st.session_state.boost_trixies_generated
                st.metric("Trixies Boost", boost_count)
        st.markdown("---")
        st.subheader("🧹 Limpeza de Cache")
        if st.button("🗑️ Limpar Todos os Caches", type="secondary"):
            cache_files = [
                L5_CACHE_FILE, SCOREBOARD_JSON_FILE, ODDS_CACHE_FILE,
                INJURIES_CACHE_FILE, MOMENTUM_CACHE_FILE, TESES_CACHE_FILE,
                DVP_CACHE_FILE, AUDIT_CACHE_FILE,
                "cache/feature_store.json",  # NOVO: Cache do Feature Store
                "cache/dynamic_thresholds.json",  # NOVO: Cache de thresholds
                "cache/boost_cache.json"  # NOVO: Cache do Boost Mode
            ]
            cleared = 0
            for cache_file in cache_files:
                if os.path.exists(cache_file):
                    try:
                        os.remove(cache_file)
                        cleared += 1
                    except:
                        pass
            # Limpar session state (exceto configurações avançadas)
            keys_to_keep = [
                "use_advanced_features", "advanced_features_config",
                "use_advanced_projections", "generate_recs", "generate_projections",
                "enhanced_trixies_generated", "filtered_trixies_count",
                "boost_trixies_generated",  # NOVO: Manter estatísticas do Boost
                "feature_store",  # Manter feature store
                "dynamic_thresholds"  # Manter thresholds
            ]
            for key in list(st.session_state.keys()):
                if key not in keys_to_keep:
                    del st.session_state[key]
            st.success(f"✅ {cleared} arquivos de cache removidos!")
            st.info("Recarregue a página para reinicializar.")
        # NOVO: Seção de exportação/importação
        st.markdown("---")
        st.subheader("📤 Exportar/Importar Configurações")
        col_e1, col_e2 = st.columns(2)
        with col_e1:
            if st.button("📤 Exportar Configurações"):
                config_data = {
                    "feature_flags": FEATURE_FLAGS,
                    "advanced_config": st.session_state.get("advanced_features_config", {}),
                    "dynamic_thresholds": st.session_state.get("dynamic_thresholds", {}),
                    "system_info": {
                        "date": TODAY,
                        "season": SEASON,
                        "cache_dir": CACHE_DIR,
                        "trixies_generated": enhanced_count,
                        "audit_count": len(audit_system.audit_data) if audit_system else 0,
                        "boost_count": st.session_state.get("boost_trixies_generated", 0)
                    }
                }
                # Criar arquivo JSON para download
                config_json = json.dumps(config_data, indent=2, ensure_ascii=False)
                st.download_button(
                    label="📥 Baixar Configurações",
                    data=config_json,
                    file_name=f"nba_analytics_config_{TODAY}.json",
                    mime="application/json"
                )
        with col_e2:
            uploaded_config = st.file_uploader("Importar configurações", type=['json'])
            if uploaded_config is not None:
                try:
                    config_data = json.load(uploaded_config)
                    if st.button("📥 Importar Configurações"):
                        # Atualizar feature flags
                        if "feature_flags" in config_data:
                            FEATURE_FLAGS.update(config_data["feature_flags"])
                        # Atualizar configurações avançadas
                        if "advanced_config" in config_data:
                            if "advanced_features_config" not in st.session_state:
                                st.session_state.advanced_features_config = {}
                            st.session_state.advanced_features_config.update(config_data["advanced_config"])
                        # Atualizar thresholds
                        if "dynamic_thresholds" in config_data:
                            st.session_state.dynamic_thresholds = config_data["dynamic_thresholds"]
                        st.success("Configurações importadas com sucesso!")
                        st.rerun()
                except Exception as e:
                    st.error(f"Erro ao importar configurações: {e}")
        st.markdown("---")
        st.subheader("🔧 Informações Técnicas")
        st.write(f"**Data atual:** {TODAY}")
        st.write(f"**Temporada:** {SEASON}")
        st.write(f"**Diretório de cache:** {CACHE_DIR}")
        st.write(f"**Total de teses disponíveis:** {len(TESE_LIST)}")
        st.write(f"**ProjectionEngine:** {'✅ Ativo' if projection_engine else '❌ Inativo'}")
        if projection_engine:
            st.write(f"  - Projeções em cache: {len(projection_engine.projections_cache)}")
            st.write(f"  - Season stats: {len(projection_engine.season_stats)} jogadores")
        # Informações do Sistema Avançado
        st.write(f"**Sistema Avançado:** {'✅ Ativado' if st.session_state.get('use_advanced_features', False) else '❌ Desativado'}")
        if st.session_state.get("use_advanced_features", False):
            config = st.session_state.get("advanced_features_config", {})
            st.write(f"  - Pace Adjuster: {'✅' if config.get('pace_adjuster') else '❌'}")
            st.write(f"  - Vacuum Matrix: {'✅' if config.get('vacuum_matrix') else '❌'}")
            st.write(f"  - Correlation Filters: {'✅' if config.get('correlation_filters') else '❌'}")
            # NOVOS: Funcionalidades do v1.6
            st.write(f"  - Dynamic Thresholds: {'✅' if config.get('dynamic_thresholds', False) else '❌'}")
            st.write(f"  - Contextual Scoring: {'✅' if config.get('contextual_scoring', False) else '❌'}")
            st.write(f"  - Boost Mode: {'✅' if config.get('boost_mode', False) else '❌'}")
        # Informações da Auditoria
        audit_system = st.session_state.get("audit_system")
        if audit_system:
            st.write(f"**Sistema de Auditoria:** ✅ Ativo")
            st.write(f"  - Trixies registradas: {len(audit_system.audit_data)}")
        # NOVO: Informações das novas funcionalidades
        st.write(f"**Novas Funcionalidades v1.6:**")
        st.write(f"  - Dynamic Thresholds: {'✅ Implementado' if FEATURE_FLAGS.get('DYNAMIC_THRESHOLDS', False) else '❌ Pendente'}")
        st.write(f"  - Contextual Scoring: {'✅ Implementado' if FEATURE_FLAGS.get('CONTEXTUAL_SCORING', False) else '❌ Pendente'}")
        st.write(f"  - Boost Mode: {'✅ Implementado' if FEATURE_FLAGS.get('BOOST_MODE', False) else '❌ Pendente'}")
        st.write(f"  - Feature Store: {'✅ Implementado' if 'feature_store' in st.session_state else '❌ Pendente'}")
        st.write(f"  - Teses de Potencial: {'✅ Implementado' if 'StealPotential' in TESE_LIST else '❌ Pendente'}")
        st.write(f"**Feature Flags ativas:** {sum(FEATURE_FLAGS.values())}/{len(FEATURE_FLAGS)}")
        st.write(f"**Módulos disponíveis:**")
        st.write(f"  - Pace Adjuster: {'✅' if PACE_ADJUSTER_AVAILABLE else '❌'}")
        st.write(f"  - Vacuum Matrix: {'✅' if VACUUM_MATRIX_AVAILABLE else '❌'}")
        st.write(f"  - Correlation Filters: {'✅' if CORRELATION_FILTERS_AVAILABLE else '❌'}")
        st.write(f"  - Enhanced System: {'✅' if ENHANCED_SYSTEM_AVAILABLE else '❌'}")
        st.write(f"  - Feature Store: {'✅' if 'feature_store' in st.session_state else '❌'}")
        # NOVO: Performance Stats
        with st.expander("⚡ Estatísticas de Performance"):
            # Calcular tempos médios de processamento
            if "performance_stats" in st.session_state:
                perf = st.session_state.performance_stats
                st.write(f"**Tempo médio de geração de trixies:** {perf.get('avg_trixie_time', 0):.2f}s")
                st.write(f"**Tempo médio de projeções:** {perf.get('avg_projection_time', 0):.2f}s")
                st.write(f"**Tempo médio de cache hit:** {perf.get('avg_cache_hit_time', 0):.2f}s")
                st.write(f"**Taxa de cache hit:** {perf.get('cache_hit_rate', 0):.1f}%")
            # Configurações de performance
            st.write(f"**Limite de trixies por jogo:**")
            for trixie_type, limit in PERFORMANCE_CONFIG.get("max_trixies_per_game", {}).items():
                st.write(f"  - {trixie_type}: {limit}")
            st.write(f"**TTL do cache:** {PERFORMANCE_CONFIG.get('cache_ttl_minutes', {}).get('stats', 30)} minutos")
    
# ============================================================================
# EXECUÇÃO PRINCIPAL
# ============================================================================
if __name__ == "__main__":
    main()