# modules/new_modules/strategy_engine.py
"""
StrategyEngine - Módulo para composição de 4 narrativas estratégicas
sem repetição de jogadores entre categorias.
"""
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Set, Optional
import logging

logger = logging.getLogger(__name__)

class StrategyEngine:
    def __init__(self, thesis_engine, correlation_validator, strategy_identifier):
        self.thesis_engine = thesis_engine
        self.correlation_validator = correlation_validator
        self.strategy_identifier = strategy_identifier
        self.recommendations = {
            "conservadora": [],
            "ousada": [],
            "banco": [],
            "explosao": []
        }
        self.used_players = set()  # Para controle de não repetição
        
    def compose_recommendations(self, players_data: pd.DataFrame, matchup_context: Dict) -> Dict:
        """
        Compõe recomendações nas 4 categorias estratégicas.
        
        Args:
            players_data: DataFrame com dados dos jogadores e teses
            matchup_context: Contexto do confronto
            
        Returns:
            Dict com recomendações para cada categoria
        """
        logger.info("Iniciando composição de estratégias...")
        
        # 1. Resetar estado
        self.recommendations = {k: [] for k in self.recommendations}
        self.used_players = set()
        
        # 2. Gerar teses para todos os jogadores
        players_with_theses = self._apply_theses_to_players(players_data, matchup_context)
        
        # 3. Compor cada estratégia em ordem de prioridade
        self._compose_conservadora(players_with_theses, matchup_context)
        self._compose_ousada(players_with_theses, matchup_context)
        self._compose_banco(players_with_theses, matchup_context)
        self._compose_explosao(players_with_theses, matchup_context)
        
        # 4. Validar correlações dentro de cada categoria
        self._validate_correlations()
        
        # 5. Identificar estratégias para cada categoria
        self._identify_strategies()
        
        logger.info(f"Composição finalizada: { {k: len(v) for k, v in self.recommendations.items()} }")
        return self.recommendations
    
    def _apply_theses_to_players(self, players_data: pd.DataFrame, context: Dict) -> pd.DataFrame:
        """Aplica teses a todos os jogadores."""
        players = players_data.copy()
        
        # Adicionar colunas de teses
        thesis_results = []
        for _, player in players.iterrows():
            player_dict = player.to_dict()
            player_theses = self.thesis_engine.evaluate_player(player_dict, context)
            thesis_results.append(player_theses)
        
        # Combinar resultados
        players['theses'] = thesis_results
        players['max_confidence'] = players['theses'].apply(
            lambda x: max([t['confidence'] for t in x]) if x else 0
        )
        players['primary_thesis'] = players['theses'].apply(
            lambda x: max(x, key=lambda t: t['confidence'])['name'] if x else None
        )
        
        return players
    
    def _compose_conservadora(self, players: pd.DataFrame, context: Dict):
        """Estratégia Conservadora: titulares com baixa volatilidade."""
        criteria = (
            (players['role'] == 'starter') &
            (players['max_confidence'] >= 0.7) &
            (~players['player_id'].isin(self.used_players))
        )
        
        candidates = players[criteria].copy()
        
        # Priorizar teses específicas para conservadora
        thesis_weights = {
            'BigRebound': 1.2,
            'AssistMatchup': 1.1,
            'ScorerLine': 1.0,
            'PaceBoost': 0.8,
            'ValueHunter': 0.5
        }
        
        candidates['strategy_score'] = candidates.apply(
            lambda row: self._calculate_strategy_score(row, thesis_weights), 
            axis=1
        )
        
        # Selecionar top 6 (máximo por confronto)
        selected = candidates.nlargest(6, 'strategy_score')
        
        for _, player in selected.iterrows():
            self._add_to_recommendation('conservadora', player, context)
    
    def _compose_ousada(self, players: pd.DataFrame, context: Dict):
        """Estratégia Ousada: alto teto estatístico (PRA ou REB+AST)."""
        # Filtrar jogadores não usados
        available = players[~players['player_id'].isin(self.used_players)].copy()
        
        # Calcular score de teto
        available['ceiling_score'] = self._calculate_ceiling_score(available)
        
        # Critérios para ousada
        criteria = (
            (available['ceiling_score'] >= 0.6) &
            (available['max_confidence'] >= 0.5)
        )
        
        candidates = available[criteria].copy()
        
        # Priorizar jogadores com PRA alto ou combinação REB+AST
        pra_weights = {
            'PTS': 0.4,
            'REB': 0.3,
            'AST': 0.3
        }
        
        candidates['pra_score'] = candidates.apply(
            lambda row: sum(row.get(stat, 0) * weight for stat, weight in pra_weights.items()),
            axis=1
        )
        
        # Combinar scores
        candidates['strategy_score'] = (
            candidates['ceiling_score'] * 0.6 + 
            candidates['pra_score'].rank(pct=True) * 0.4
        )
        
        # Selecionar top 4
        selected = candidates.nlargest(4, 'strategy_score')
        
        for _, player in selected.iterrows():
            self._add_to_recommendation('ousada', player, context)
    
    def _compose_banco(self, players: pd.DataFrame, context: Dict):
        """Estratégia Banco: valor em reservas e garbage time."""
        available = players[~players['player_id'].isin(self.used_players)].copy()
        
        # Critérios para banco
        criteria = (
            (available['role'].isin(['rotation', 'bench'])) &
            (available['max_confidence'] >= 0.5)
        )
        
        candidates = available[criteria].copy()
        
        # Priorizar ValueHunter
        value_weights = {
            'ValueHunter': 1.5,
            'PaceBoost': 1.2,
            'ScorerLine': 0.8,
            'AssistMatchup': 0.7
        }
        
        candidates['value_score'] = candidates.apply(
            lambda row: self._calculate_strategy_score(row, value_weights), 
            axis=1
        )
        
        # Adicionar fator de garbage time em blowouts
        spread = context.get('spread', 0)
        if abs(spread) >= 10:
            # Time perdendo por muito pode ter garbage time
            for team in ['home', 'away']:
                if context.get(f'{team}_is_losing', False):
                    team_candidates = candidates[candidates['team'] == context[f'{team}_team']]
                    if not team_candidates.empty:
                        team_candidates['value_score'] *= 1.3
        
        # Selecionar top 5
        selected = candidates.nlargest(5, 'value_score')
        
        for _, player in selected.iterrows():
            self._add_to_recommendation('banco', player, context)
    
    def _compose_explosao(self, players: pd.DataFrame, context: Dict):
        """Estratégia Explosão: contexto situacional e lineup shocks."""
        available = players[~players['player_id'].isin(self.used_players)].copy()
        
        # Critérios para explosão
        explosion_factors = []
        
        for _, player in available.iterrows():
            factor = 1.0
            
            # 1. Check for lineup shocks (injuries in same position)
            position = player['position']
            team = player['team']
            
            # Verificar se há lesionados na mesma posição
            injured_same_pos = context.get('injuries', {}).get(team, {}).get(position, 0)
            if injured_same_pos > 0:
                factor *= 1.0 + (injured_same_pos * 0.2)
            
            # 2. Pace extremo
            pace = context.get('pace', 100)
            if pace >= 110:
                factor *= 1.3
            elif pace <= 90:
                factor *= 1.1
            
            # 3. Matchup extremamente favorável
            dvp_advantage = player.get('dvp_advantage', 0)
            if dvp_advantage >= 15:
                factor *= 1.4
            elif dvp_advantage <= -15:
                factor *= 0.7
            
            # 4. Recent hot streak
            recent_form = player.get('form_last_5', 0)
            if recent_form >= 1.2:
                factor *= 1.2
            
            explosion_factors.append(factor)
        
        available['explosion_factor'] = explosion_factors
        available['strategy_score'] = available['max_confidence'] * available['explosion_factor']
        
        # Selecionar top 3
        selected = available.nlargest(3, 'strategy_score')
        
        for _, player in selected.iterrows():
            self._add_to_recommendation('explosao', player, context)
    
    def _calculate_strategy_score(self, player: pd.Series, thesis_weights: Dict) -> float:
        """Calcula score baseado em pesos de teses."""
        if not isinstance(player['theses'], list):
            return 0.0
        
        total_score = 0.0
        max_weight = 0.0
        
        for thesis in player['theses']:
            weight = thesis_weights.get(thesis['name'], 1.0)
            score = thesis['confidence'] * weight
            total_score += score
            max_weight = max(max_weight, weight)
        
        return total_score / max(len(player['theses']), 1) if max_weight > 0 else 0.0
    
    def _calculate_ceiling_score(self, players: pd.DataFrame) -> pd.Series:
        """Calcula score de teto estatístico."""
        scores = []
        
        for _, player in players.iterrows():
            score = 0.0
            
            # Fatores de teto
            factors = {
                'usage_rate': player.get('usage_rate', 0) / 30,  # Normalizado
                'minutes_avg': min(player.get('minutes_avg', 0) / 35, 1.0),
                'pra_per_min': player.get('pra_per_min', 0) * 2,  # Multiplicador
                'ceiling_last_10': player.get('ceiling_last_10', 0) / 50  # Ex: 50 PRA máximo
            }
            
            # Média ponderada
            weights = [0.3, 0.2, 0.3, 0.2]
            score = sum(f * w for f, w in zip(factors.values(), weights))
            
            scores.append(min(score, 1.0))  # Cap em 1.0
        
        return pd.Series(scores, index=players.index)
    
    def _add_to_recommendation(self, category: str, player: pd.Series, context: Dict):
        """Adiciona jogador à recomendação da categoria."""
        player_id = player['player_id']
        
        if player_id in self.used_players:
            logger.warning(f"Jogador {player_id} já usado, pulando...")
            return
        
        # Preparar recomendação
        recommendation = {
            'player_id': player_id,
            'name': player['name'],
            'position': player['position'],
            'team': player['team'],
            'role': player['role'],
            'primary_thesis': player['primary_thesis'],
            'confidence': player['max_confidence'],
            'theses': player['theses'],
            'stats': {
                'pts_avg': player.get('pts_avg', 0),
                'reb_avg': player.get('reb_avg', 0),
                'ast_avg': player.get('ast_avg', 0),
                'pra_avg': player.get('pts_avg', 0) + player.get('reb_avg', 0) + player.get('ast_avg', 0)
            }
        }
        
        # Adicionar evidências contextuais
        recommendation['evidence'] = self._gather_evidence(player, context)
        
        self.recommendations[category].append(recommendation)
        self.used_players.add(player_id)
        
        logger.debug(f"Adicionado {player['name']} à categoria {category}")
    
    def _gather_evidence(self, player: pd.Series, context: Dict) -> Dict:
        """Coleta evidências para a recomendação."""
        evidence = {
            'matchup': {
                'pace': context.get('pace', 0),
                'spread': context.get('spread', 0),
                'total': context.get('total', 0),
                'dvp_rank': player.get('dvp_rank', 'N/A')
            },
            'role_factors': {
                'minutes_proj': player.get('minutes_proj', 0),
                'usage_rate': player.get('usage_rate', 0),
                'lineup_impact': player.get('lineup_impact', 0)
            },
            'situational': {
                'blowout_risk': context.get('blowout_risk', False),
                'injury_boost': context.get('injury_boost', False),
                'pace_boost': context.get('pace_boost', False)
            }
        }
        
        # Adicionar evidências específicas das teses
        thesis_evidence = {}
        for thesis in player.get('theses', []):
            thesis_evidence[thesis['name']] = {
                'confidence': thesis['confidence'],
                'motives': thesis.get('motives', []),
                'evidence': thesis.get('evidence', {})
            }
        
        evidence['theses'] = thesis_evidence
        return evidence
    
    def _validate_correlations(self):
        """Valida correlações dentro de cada categoria."""
        for category, recs in self.recommendations.items():
            if len(recs) < 2:
                continue
            
            # Extrair player_ids
            player_ids = [r['player_id'] for r in recs]
            
            # Validar com CorrelationValidator
            try:
                validated = self.correlation_validator.validate_group(
                    player_ids=player_ids,
                    category=category
                )
                
                # Remover jogadores com correlação problemática
                if 'problematic_pairs' in validated:
                    problematic = set()
                    for pair in validated['problematic_pairs']:
                        # Remover o jogador com menor confiança
                        rec1 = next(r for r in recs if r['player_id'] == pair[0])
                        rec2 = next(r for r in recs if r['player_id'] == pair[1])
                        
                        if rec1['confidence'] < rec2['confidence']:
                            problematic.add(rec1['player_id'])
                        else:
                            problematic.add(rec2['player_id'])
                    
                    # Atualizar recomendações
                    self.recommendations[category] = [
                        r for r in recs if r['player_id'] not in problematic
                    ]
                    
                    logger.info(f"Categoria {category}: Removidos {len(problematic)} jogadores por correlação")
                    
            except Exception as e:
                logger.error(f"Erro na validação de correlação ({category}): {e}")
    
    def _identify_strategies(self):
        """Identifica estratégias para cada categoria."""
        for category, recs in self.recommendations.items():
            if not recs:
                continue
            
            player_ids = [r['player_id'] for r in recs]
            strategies = self.strategy_identifier.identify(player_ids)
            
            # Adicionar identificação às recomendações
            for rec in recs:
                rec['strategy_tags'] = strategies.get(rec['player_id'], [])
    
    def get_recommendation_summary(self) -> Dict:
        """Retorna resumo das recomendações."""
        summary = {}
        
        for category, recs in self.recommendations.items():
            summary[category] = {
                'count': len(recs),
                'players': [
                    {
                        'name': r['name'],
                        'position': r['position'],
                        'team': r['team'],
                        'primary_thesis': r['primary_thesis'],
                        'confidence': round(r['confidence'], 2),
                        'pra_avg': r['stats']['pra_avg']
                    }
                    for r in recs[:5]  # Limitar a 5 por visibilidade
                ],
                'avg_confidence': round(
                    np.mean([r['confidence'] for r in recs]) if recs else 0, 2
                ),
                'strategy_diversity': len(set(r['team'] for r in recs)) if recs else 0
            }
        
        return summary